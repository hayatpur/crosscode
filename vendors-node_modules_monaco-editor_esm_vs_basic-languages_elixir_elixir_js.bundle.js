(self["webpackChunkcross_code"] = self["webpackChunkcross_code"] || []).push([["vendors-node_modules_monaco-editor_esm_vs_basic-languages_elixir_elixir_js"],{

/***/ "./node_modules/monaco-editor/esm/vs/basic-languages/elixir/elixir.js":
/*!****************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/basic-languages/elixir/elixir.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "conf": () => (/* binding */ conf),
/* harmony export */   "language": () => (/* binding */ language)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var conf = {
    comments: {
        lineComment: '#'
    },
    brackets: [
        ['{', '}'],
        ['[', ']'],
        ['(', ')']
    ],
    surroundingPairs: [
        { open: '{', close: '}' },
        { open: '[', close: ']' },
        { open: '(', close: ')' },
        { open: "'", close: "'" },
        { open: '"', close: '"' }
    ],
    autoClosingPairs: [
        { open: "'", close: "'", notIn: ['string', 'comment'] },
        { open: '"', close: '"', notIn: ['comment'] },
        { open: '"""', close: '"""' },
        { open: '`', close: '`', notIn: ['string', 'comment'] },
        { open: '(', close: ')' },
        { open: '{', close: '}' },
        { open: '[', close: ']' },
        { open: '<<', close: '>>' }
    ],
    indentationRules: {
        increaseIndentPattern: /^\s*(after|else|catch|rescue|fn|[^#]*(do|<\-|\->|\{|\[|\=))\s*$/,
        decreaseIndentPattern: /^\s*((\}|\])\s*$|(after|else|catch|rescue|end)\b)/
    }
};
/**
 * A Monarch lexer for the Elixir language.
 *
 * References:
 *
 * * Monarch documentation - https://microsoft.github.io/monaco-editor/monarch.html
 * * Elixir lexer - https://github.com/elixir-makeup/makeup_elixir/blob/master/lib/makeup/lexers/elixir_lexer.ex
 * * TextMate lexer (elixir-tmbundle) - https://github.com/elixir-editors/elixir-tmbundle/blob/master/Syntaxes/Elixir.tmLanguage
 * * TextMate lexer (vscode-elixir-ls) - https://github.com/elixir-lsp/vscode-elixir-ls/blob/master/syntaxes/elixir.json
 */
var language = {
    defaultToken: 'source',
    tokenPostfix: '.elixir',
    brackets: [
        { open: '[', close: ']', token: 'delimiter.square' },
        { open: '(', close: ')', token: 'delimiter.parenthesis' },
        { open: '{', close: '}', token: 'delimiter.curly' },
        { open: '<<', close: '>>', token: 'delimiter.angle.special' }
    ],
    // Below are lists/regexps to which we reference later.
    declarationKeywords: [
        'def',
        'defp',
        'defn',
        'defnp',
        'defguard',
        'defguardp',
        'defmacro',
        'defmacrop',
        'defdelegate',
        'defcallback',
        'defmacrocallback',
        'defmodule',
        'defprotocol',
        'defexception',
        'defimpl',
        'defstruct'
    ],
    operatorKeywords: ['and', 'in', 'not', 'or', 'when'],
    namespaceKeywords: ['alias', 'import', 'require', 'use'],
    otherKeywords: [
        'after',
        'case',
        'catch',
        'cond',
        'do',
        'else',
        'end',
        'fn',
        'for',
        'if',
        'quote',
        'raise',
        'receive',
        'rescue',
        'super',
        'throw',
        'try',
        'unless',
        'unquote_splicing',
        'unquote',
        'with'
    ],
    constants: ['true', 'false', 'nil'],
    nameBuiltin: ['__MODULE__', '__DIR__', '__ENV__', '__CALLER__', '__STACKTRACE__'],
    // Matches any of the operator names:
    // <<< >>> ||| &&& ^^^ ~~~ === !== ~>> <~> |~> <|> == != <= >= && || \\ <> ++ -- |> =~ -> <- ~> <~ :: .. = < > + - * / | . ^ & !
    operator: /-[->]?|!={0,2}|\*|\/|\\\\|&{1,3}|\.\.?|\^(?:\^\^)?|\+\+?|<(?:-|<<|=|>|\|>|~>?)?|=~|={1,3}|>(?:=|>>)?|\|~>|\|>|\|{1,3}|~>>?|~~~|::/,
    // See https://hexdocs.pm/elixir/syntax-reference.html#variables
    variableName: /[a-z_][a-zA-Z0-9_]*[?!]?/,
    // See https://hexdocs.pm/elixir/syntax-reference.html#atoms
    atomName: /[a-zA-Z_][a-zA-Z0-9_@]*[?!]?|@specialAtomName|@operator/,
    specialAtomName: /\.\.\.|<<>>|%\{\}|%|\{\}/,
    aliasPart: /[A-Z][a-zA-Z0-9_]*/,
    moduleName: /@aliasPart(?:\.@aliasPart)*/,
    // Sigil pairs are: """ """, ''' ''', " ", ' ', / /, | |, < >, { }, [ ], ( )
    sigilSymmetricDelimiter: /"""|'''|"|'|\/|\|/,
    sigilStartDelimiter: /@sigilSymmetricDelimiter|<|\{|\[|\(/,
    sigilEndDelimiter: /@sigilSymmetricDelimiter|>|\}|\]|\)/,
    decimal: /\d(?:_?\d)*/,
    hex: /[0-9a-fA-F](_?[0-9a-fA-F])*/,
    octal: /[0-7](_?[0-7])*/,
    binary: /[01](_?[01])*/,
    // See https://hexdocs.pm/elixir/master/String.html#module-escape-characters
    escape: /\\u[0-9a-fA-F]{4}|\\x[0-9a-fA-F]{2}|\\./,
    // The keys below correspond to tokenizer states.
    // We start from the root state and match against its rules
    // until we explicitly transition into another state.
    // The `include` simply brings in all operations from the given state
    // and is useful for improving readability.
    tokenizer: {
        root: [
            { include: '@whitespace' },
            { include: '@comments' },
            // Keywords start as either an identifier or a string,
            // but end with a : so it's important to match this first.
            { include: '@keywordsShorthand' },
            { include: '@numbers' },
            { include: '@identifiers' },
            { include: '@strings' },
            { include: '@atoms' },
            { include: '@sigils' },
            { include: '@attributes' },
            { include: '@symbols' }
        ],
        // Whitespace
        whitespace: [[/\s+/, 'white']],
        // Comments
        comments: [[/(#)(.*)/, ['comment.punctuation', 'comment']]],
        // Keyword list shorthand
        keywordsShorthand: [
            [/(@atomName)(:)/, ['constant', 'constant.punctuation']],
            // Use positive look-ahead to ensure the string is followed by :
            // and should be considered a keyword.
            [
                /"(?=([^"]|#\{.*?\}|\\")*":)/,
                { token: 'constant.delimiter', next: '@doubleQuotedStringKeyword' }
            ],
            [
                /'(?=([^']|#\{.*?\}|\\')*':)/,
                { token: 'constant.delimiter', next: '@singleQuotedStringKeyword' }
            ]
        ],
        doubleQuotedStringKeyword: [
            [/":/, { token: 'constant.delimiter', next: '@pop' }],
            { include: '@stringConstantContentInterpol' }
        ],
        singleQuotedStringKeyword: [
            [/':/, { token: 'constant.delimiter', next: '@pop' }],
            { include: '@stringConstantContentInterpol' }
        ],
        // Numbers
        numbers: [
            [/0b@binary/, 'number.binary'],
            [/0o@octal/, 'number.octal'],
            [/0x@hex/, 'number.hex'],
            [/@decimal\.@decimal([eE]-?@decimal)?/, 'number.float'],
            [/@decimal/, 'number']
        ],
        // Identifiers
        identifiers: [
            // Tokenize identifier name in function-like definitions.
            // Note: given `def a + b, do: nil`, `a` is not a function name,
            // so we use negative look-ahead to ensure there's no operator.
            [
                /\b(defp?|defnp?|defmacrop?|defguardp?|defdelegate)(\s+)(@variableName)(?!\s+@operator)/,
                [
                    'keyword.declaration',
                    'white',
                    {
                        cases: {
                            unquote: 'keyword',
                            '@default': 'function'
                        }
                    }
                ]
            ],
            // Tokenize function calls
            [
                // In-scope call - an identifier followed by ( or .(
                /(@variableName)(?=\s*\.?\s*\()/,
                {
                    cases: {
                        // Tokenize as keyword in cases like `if(..., do: ..., else: ...)`
                        '@declarationKeywords': 'keyword.declaration',
                        '@namespaceKeywords': 'keyword',
                        '@otherKeywords': 'keyword',
                        '@default': 'function.call'
                    }
                }
            ],
            [
                // Referencing function in a module
                /(@moduleName)(\s*)(\.)(\s*)(@variableName)/,
                ['type.identifier', 'white', 'operator', 'white', 'function.call']
            ],
            [
                // Referencing function in an Erlang module
                /(:)(@atomName)(\s*)(\.)(\s*)(@variableName)/,
                ['constant.punctuation', 'constant', 'white', 'operator', 'white', 'function.call']
            ],
            [
                // Piping into a function (tokenized separately as it may not have parentheses)
                /(\|>)(\s*)(@variableName)/,
                [
                    'operator',
                    'white',
                    {
                        cases: {
                            '@otherKeywords': 'keyword',
                            '@default': 'function.call'
                        }
                    }
                ]
            ],
            [
                // Function reference passed to another function
                /(&)(\s*)(@variableName)/,
                ['operator', 'white', 'function.call']
            ],
            // Language keywords, builtins, constants and variables
            [
                /@variableName/,
                {
                    cases: {
                        '@declarationKeywords': 'keyword.declaration',
                        '@operatorKeywords': 'keyword.operator',
                        '@namespaceKeywords': 'keyword',
                        '@otherKeywords': 'keyword',
                        '@constants': 'constant.language',
                        '@nameBuiltin': 'variable.language',
                        '_.*': 'comment.unused',
                        '@default': 'identifier'
                    }
                }
            ],
            // Module names
            [/@moduleName/, 'type.identifier']
        ],
        // Strings
        strings: [
            [/"""/, { token: 'string.delimiter', next: '@doubleQuotedHeredoc' }],
            [/'''/, { token: 'string.delimiter', next: '@singleQuotedHeredoc' }],
            [/"/, { token: 'string.delimiter', next: '@doubleQuotedString' }],
            [/'/, { token: 'string.delimiter', next: '@singleQuotedString' }]
        ],
        doubleQuotedHeredoc: [
            [/"""/, { token: 'string.delimiter', next: '@pop' }],
            { include: '@stringContentInterpol' }
        ],
        singleQuotedHeredoc: [
            [/'''/, { token: 'string.delimiter', next: '@pop' }],
            { include: '@stringContentInterpol' }
        ],
        doubleQuotedString: [
            [/"/, { token: 'string.delimiter', next: '@pop' }],
            { include: '@stringContentInterpol' }
        ],
        singleQuotedString: [
            [/'/, { token: 'string.delimiter', next: '@pop' }],
            { include: '@stringContentInterpol' }
        ],
        // Atoms
        atoms: [
            [/(:)(@atomName)/, ['constant.punctuation', 'constant']],
            [/:"/, { token: 'constant.delimiter', next: '@doubleQuotedStringAtom' }],
            [/:'/, { token: 'constant.delimiter', next: '@singleQuotedStringAtom' }]
        ],
        doubleQuotedStringAtom: [
            [/"/, { token: 'constant.delimiter', next: '@pop' }],
            { include: '@stringConstantContentInterpol' }
        ],
        singleQuotedStringAtom: [
            [/'/, { token: 'constant.delimiter', next: '@pop' }],
            { include: '@stringConstantContentInterpol' }
        ],
        // Sigils
        // See https://elixir-lang.org/getting-started/sigils.html
        // Sigils allow for typing values using their textual representation.
        // All sigils start with ~ followed by a letter indicating sigil type
        // and then a delimiter pair enclosing the textual representation.
        // Optional modifiers are allowed after the closing delimiter.
        // For instance a regular expressions can be written as:
        // ~r/foo|bar/ ~r{foo|bar} ~r/foo|bar/g
        //
        // In general lowercase sigils allow for interpolation
        // and escaped characters, whereas uppercase sigils don't
        //
        // During tokenization we want to distinguish some
        // specific sigil types, namely string and regexp,
        // so that they cen be themed separately.
        //
        // To reasonably handle all those combinations we leverage
        // dot-separated states, so if we transition to @sigilStart.interpol.s.{.}
        // then "sigilStart.interpol.s" state will match and also all
        // the individual dot-separated parameters can be accessed.
        sigils: [
            [/~[a-z]@sigilStartDelimiter/, { token: '@rematch', next: '@sigil.interpol' }],
            [/~[A-Z]@sigilStartDelimiter/, { token: '@rematch', next: '@sigil.noInterpol' }]
        ],
        sigil: [
            [/~([a-zA-Z])\{/, { token: '@rematch', switchTo: '@sigilStart.$S2.$1.{.}' }],
            [/~([a-zA-Z])\[/, { token: '@rematch', switchTo: '@sigilStart.$S2.$1.[.]' }],
            [/~([a-zA-Z])\(/, { token: '@rematch', switchTo: '@sigilStart.$S2.$1.(.)' }],
            [/~([a-zA-Z])\</, { token: '@rematch', switchTo: '@sigilStart.$S2.$1.<.>' }],
            [
                /~([a-zA-Z])(@sigilSymmetricDelimiter)/,
                { token: '@rematch', switchTo: '@sigilStart.$S2.$1.$2.$2' }
            ]
        ],
        // The definitions below expect states to be of the form:
        //
        // sigilStart.<interpol-or-noInterpol>.<sigil-letter>.<start-delimiter>.<end-delimiter>
        // sigilContinue.<interpol-or-noInterpol>.<sigil-letter>.<start-delimiter>.<end-delimiter>
        //
        // The sigilStart state is used only to properly classify the token (as string/regex/sigil)
        // and immediately switches to the sigilContinue sate, which handles the actual content
        // and waits for the corresponding end delimiter.
        'sigilStart.interpol.s': [
            [
                /~s@sigilStartDelimiter/,
                {
                    token: 'string.delimiter',
                    switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'
                }
            ]
        ],
        'sigilContinue.interpol.s': [
            [
                /(@sigilEndDelimiter)[a-zA-Z]*/,
                {
                    cases: {
                        '$1==$S5': { token: 'string.delimiter', next: '@pop' },
                        '@default': 'string'
                    }
                }
            ],
            { include: '@stringContentInterpol' }
        ],
        'sigilStart.noInterpol.S': [
            [
                /~S@sigilStartDelimiter/,
                {
                    token: 'string.delimiter',
                    switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'
                }
            ]
        ],
        'sigilContinue.noInterpol.S': [
            // Ignore escaped sigil end
            [/(^|[^\\])\\@sigilEndDelimiter/, 'string'],
            [
                /(@sigilEndDelimiter)[a-zA-Z]*/,
                {
                    cases: {
                        '$1==$S5': { token: 'string.delimiter', next: '@pop' },
                        '@default': 'string'
                    }
                }
            ],
            { include: '@stringContent' }
        ],
        'sigilStart.interpol.r': [
            [
                /~r@sigilStartDelimiter/,
                {
                    token: 'regexp.delimiter',
                    switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'
                }
            ]
        ],
        'sigilContinue.interpol.r': [
            [
                /(@sigilEndDelimiter)[a-zA-Z]*/,
                {
                    cases: {
                        '$1==$S5': { token: 'regexp.delimiter', next: '@pop' },
                        '@default': 'regexp'
                    }
                }
            ],
            { include: '@regexpContentInterpol' }
        ],
        'sigilStart.noInterpol.R': [
            [
                /~R@sigilStartDelimiter/,
                {
                    token: 'regexp.delimiter',
                    switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'
                }
            ]
        ],
        'sigilContinue.noInterpol.R': [
            // Ignore escaped sigil end
            [/(^|[^\\])\\@sigilEndDelimiter/, 'regexp'],
            [
                /(@sigilEndDelimiter)[a-zA-Z]*/,
                {
                    cases: {
                        '$1==$S5': { token: 'regexp.delimiter', next: '@pop' },
                        '@default': 'regexp'
                    }
                }
            ],
            { include: '@regexpContent' }
        ],
        // Fallback to the generic sigil by default
        'sigilStart.interpol': [
            [
                /~([a-zA-Z])@sigilStartDelimiter/,
                {
                    token: 'sigil.delimiter',
                    switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'
                }
            ]
        ],
        'sigilContinue.interpol': [
            [
                /(@sigilEndDelimiter)[a-zA-Z]*/,
                {
                    cases: {
                        '$1==$S5': { token: 'sigil.delimiter', next: '@pop' },
                        '@default': 'sigil'
                    }
                }
            ],
            { include: '@sigilContentInterpol' }
        ],
        'sigilStart.noInterpol': [
            [
                /~([a-zA-Z])@sigilStartDelimiter/,
                {
                    token: 'sigil.delimiter',
                    switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'
                }
            ]
        ],
        'sigilContinue.noInterpol': [
            // Ignore escaped sigil end
            [/(^|[^\\])\\@sigilEndDelimiter/, 'sigil'],
            [
                /(@sigilEndDelimiter)[a-zA-Z]*/,
                {
                    cases: {
                        '$1==$S5': { token: 'sigil.delimiter', next: '@pop' },
                        '@default': 'sigil'
                    }
                }
            ],
            { include: '@sigilContent' }
        ],
        // Attributes
        attributes: [
            // Module @doc* attributes - tokenized as comments
            [
                /\@(module|type)?doc (~[sS])?"""/,
                {
                    token: 'comment.block.documentation',
                    next: '@doubleQuotedHeredocDocstring'
                }
            ],
            [
                /\@(module|type)?doc (~[sS])?"/,
                {
                    token: 'comment.block.documentation',
                    next: '@doubleQuotedStringDocstring'
                }
            ],
            [/\@(module|type)?doc false/, 'comment.block.documentation'],
            // Module attributes
            [/\@(@variableName)/, 'variable']
        ],
        doubleQuotedHeredocDocstring: [
            [/"""/, { token: 'comment.block.documentation', next: '@pop' }],
            { include: '@docstringContent' }
        ],
        doubleQuotedStringDocstring: [
            [/"/, { token: 'comment.block.documentation', next: '@pop' }],
            { include: '@docstringContent' }
        ],
        // Operators, punctuation, brackets
        symbols: [
            // Code point operator (either with regular character ?a or an escaped one ?\n)
            [/\?(\\.|[^\\\s])/, 'number.constant'],
            // Anonymous function arguments
            [/&\d+/, 'operator'],
            // Bitshift operators (must go before delimiters, so that << >> don't match first)
            [/<<<|>>>/, 'operator'],
            // Delimiter pairs
            [/[()\[\]\{\}]|<<|>>/, '@brackets'],
            // Triple dot is a valid name (must go before operators, so that .. doesn't match instead)
            [/\.\.\./, 'identifier'],
            // Punctuation => (must go before operators, so it's not tokenized as = then >)
            [/=>/, 'punctuation'],
            // Operators
            [/@operator/, 'operator'],
            // Punctuation
            [/[:;,.%]/, 'punctuation']
        ],
        // Generic helpers
        stringContentInterpol: [
            { include: '@interpolation' },
            { include: '@escapeChar' },
            { include: '@stringContent' }
        ],
        stringContent: [[/./, 'string']],
        stringConstantContentInterpol: [
            { include: '@interpolation' },
            { include: '@escapeChar' },
            { include: '@stringConstantContent' }
        ],
        stringConstantContent: [[/./, 'constant']],
        regexpContentInterpol: [
            { include: '@interpolation' },
            { include: '@escapeChar' },
            { include: '@regexpContent' }
        ],
        regexpContent: [
            // # may be a regular regexp char, so we use a heuristic
            // assuming a # surrounded by whitespace is actually a comment.
            [/(\s)(#)(\s.*)$/, ['white', 'comment.punctuation', 'comment']],
            [/./, 'regexp']
        ],
        sigilContentInterpol: [
            { include: '@interpolation' },
            { include: '@escapeChar' },
            { include: '@sigilContent' }
        ],
        sigilContent: [[/./, 'sigil']],
        docstringContent: [[/./, 'comment.block.documentation']],
        escapeChar: [[/@escape/, 'constant.character.escape']],
        interpolation: [
            [/#{/, { token: 'delimiter.bracket.embed', next: '@interpolationContinue' }]
        ],
        interpolationContinue: [
            [/}/, { token: 'delimiter.bracket.embed', next: '@pop' }],
            // Interpolation brackets may contain arbitrary code,
            // so we simply match against all the root rules,
            // until we reach interpolation end (the above matches).
            { include: '@root' }
        ]
    }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcm9zcy1jb2RlLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2ljLWxhbmd1YWdlcy9lbGl4aXIvZWxpeGlyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFNBQVMsWUFBWSxHQUFHO0FBQ2pDLFNBQVMsd0JBQXdCO0FBQ2pDLFNBQVMsd0JBQXdCO0FBQ2pDLFNBQVMsd0JBQXdCO0FBQ2pDLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUyxzREFBc0Q7QUFDL0QsU0FBUyw0Q0FBNEM7QUFDckQsU0FBUyw0QkFBNEI7QUFDckMsU0FBUyxzREFBc0Q7QUFDL0QsU0FBUyx3QkFBd0I7QUFDakMsU0FBUyxTQUFTLFlBQVksR0FBRztBQUNqQyxTQUFTLHdCQUF3QjtBQUNqQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRix3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1EQUFtRDtBQUM1RCxTQUFTLHdEQUF3RDtBQUNqRSxTQUFTLFNBQVMsWUFBWSw2QkFBNkI7QUFDM0QsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLElBQUksY0FBYyxJQUFJLHFEQUFxRCxJQUFJLHdCQUF3QixJQUFJO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEVBQUUsS0FBSyxFQUFFO0FBQzlDO0FBQ0E7QUFDQSxvRUFBb0UsRUFBRTtBQUN0RTtBQUNBLHVEQUF1RDtBQUN2RCxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixFQUFFLGdCQUFnQixFQUFFO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEMsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBLGFBQWEsZ0NBQWdDO0FBQzdDLGFBQWEsc0JBQXNCO0FBQ25DLGFBQWEsMEJBQTBCO0FBQ3ZDLGFBQWEsc0JBQXNCO0FBQ25DLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEscUJBQXFCO0FBQ2xDLGFBQWEseUJBQXlCO0FBQ3RDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEtBQUs7QUFDbkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSw4QkFBOEIsS0FBSztBQUNuQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRDQUE0QztBQUNoRSxhQUFhO0FBQ2I7QUFDQTtBQUNBLG9CQUFvQiw0Q0FBNEM7QUFDaEUsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBEQUEwRDtBQUMvRSxxQkFBcUIsMERBQTBEO0FBQy9FLG1CQUFtQix5REFBeUQ7QUFDNUUsbUJBQW1CLHlEQUF5RDtBQUM1RTtBQUNBO0FBQ0EscUJBQXFCLDBDQUEwQztBQUMvRCxhQUFhO0FBQ2I7QUFDQTtBQUNBLHFCQUFxQiwwQ0FBMEM7QUFDL0QsYUFBYTtBQUNiO0FBQ0E7QUFDQSxtQkFBbUIsMENBQTBDO0FBQzdELGFBQWE7QUFDYjtBQUNBO0FBQ0EsbUJBQW1CLDBDQUEwQztBQUM3RCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0RBQStEO0FBQ25GLG9CQUFvQiwrREFBK0Q7QUFDbkY7QUFDQTtBQUNBLG1CQUFtQiw0Q0FBNEM7QUFDL0QsYUFBYTtBQUNiO0FBQ0E7QUFDQSxtQkFBbUIsNENBQTRDO0FBQy9ELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyw2Q0FBNkM7QUFDekYsNENBQTRDLCtDQUErQztBQUMzRjtBQUNBO0FBQ0EsMkJBQTJCLElBQUksbURBQW1ELEVBQUUsR0FBRztBQUN2RiwrQkFBK0Isd0RBQXdEO0FBQ3ZGLCtCQUErQix3REFBd0Q7QUFDdkYsK0JBQStCLHdEQUF3RDtBQUN2RjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywwQ0FBMEM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywwQ0FBMEM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDBDQUEwQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDBDQUEwQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx5Q0FBeUM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx5Q0FBeUM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxREFBcUQ7QUFDMUUsYUFBYTtBQUNiO0FBQ0E7QUFDQSxtQkFBbUIscURBQXFEO0FBQ3hFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixFQUFFO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNEJBQTRCO0FBQ3pDLGFBQWEseUJBQXlCO0FBQ3RDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhLDRCQUE0QjtBQUN6QyxhQUFhLHlCQUF5QjtBQUN0QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYSw0QkFBNEI7QUFDekMsYUFBYSx5QkFBeUI7QUFDdEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDRCQUE0QjtBQUN6QyxhQUFhLHlCQUF5QjtBQUN0QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixJQUFJLG1FQUFtRTtBQUN2RjtBQUNBO0FBQ0EsZUFBZSxJQUFJLGlEQUFpRDtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBIiwiZmlsZSI6InZlbmRvcnMtbm9kZV9tb2R1bGVzX21vbmFjby1lZGl0b3JfZXNtX3ZzX2Jhc2ljLWxhbmd1YWdlc19lbGl4aXJfZWxpeGlyX2pzLmJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5leHBvcnQgdmFyIGNvbmYgPSB7XHJcbiAgICBjb21tZW50czoge1xyXG4gICAgICAgIGxpbmVDb21tZW50OiAnIydcclxuICAgIH0sXHJcbiAgICBicmFja2V0czogW1xyXG4gICAgICAgIFsneycsICd9J10sXHJcbiAgICAgICAgWydbJywgJ10nXSxcclxuICAgICAgICBbJygnLCAnKSddXHJcbiAgICBdLFxyXG4gICAgc3Vycm91bmRpbmdQYWlyczogW1xyXG4gICAgICAgIHsgb3BlbjogJ3snLCBjbG9zZTogJ30nIH0sXHJcbiAgICAgICAgeyBvcGVuOiAnWycsIGNsb3NlOiAnXScgfSxcclxuICAgICAgICB7IG9wZW46ICcoJywgY2xvc2U6ICcpJyB9LFxyXG4gICAgICAgIHsgb3BlbjogXCInXCIsIGNsb3NlOiBcIidcIiB9LFxyXG4gICAgICAgIHsgb3BlbjogJ1wiJywgY2xvc2U6ICdcIicgfVxyXG4gICAgXSxcclxuICAgIGF1dG9DbG9zaW5nUGFpcnM6IFtcclxuICAgICAgICB7IG9wZW46IFwiJ1wiLCBjbG9zZTogXCInXCIsIG5vdEluOiBbJ3N0cmluZycsICdjb21tZW50J10gfSxcclxuICAgICAgICB7IG9wZW46ICdcIicsIGNsb3NlOiAnXCInLCBub3RJbjogWydjb21tZW50J10gfSxcclxuICAgICAgICB7IG9wZW46ICdcIlwiXCInLCBjbG9zZTogJ1wiXCJcIicgfSxcclxuICAgICAgICB7IG9wZW46ICdgJywgY2xvc2U6ICdgJywgbm90SW46IFsnc3RyaW5nJywgJ2NvbW1lbnQnXSB9LFxyXG4gICAgICAgIHsgb3BlbjogJygnLCBjbG9zZTogJyknIH0sXHJcbiAgICAgICAgeyBvcGVuOiAneycsIGNsb3NlOiAnfScgfSxcclxuICAgICAgICB7IG9wZW46ICdbJywgY2xvc2U6ICddJyB9LFxyXG4gICAgICAgIHsgb3BlbjogJzw8JywgY2xvc2U6ICc+PicgfVxyXG4gICAgXSxcclxuICAgIGluZGVudGF0aW9uUnVsZXM6IHtcclxuICAgICAgICBpbmNyZWFzZUluZGVudFBhdHRlcm46IC9eXFxzKihhZnRlcnxlbHNlfGNhdGNofHJlc2N1ZXxmbnxbXiNdKihkb3w8XFwtfFxcLT58XFx7fFxcW3xcXD0pKVxccyokLyxcclxuICAgICAgICBkZWNyZWFzZUluZGVudFBhdHRlcm46IC9eXFxzKigoXFx9fFxcXSlcXHMqJHwoYWZ0ZXJ8ZWxzZXxjYXRjaHxyZXNjdWV8ZW5kKVxcYikvXHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBBIE1vbmFyY2ggbGV4ZXIgZm9yIHRoZSBFbGl4aXIgbGFuZ3VhZ2UuXHJcbiAqXHJcbiAqIFJlZmVyZW5jZXM6XHJcbiAqXHJcbiAqICogTW9uYXJjaCBkb2N1bWVudGF0aW9uIC0gaHR0cHM6Ly9taWNyb3NvZnQuZ2l0aHViLmlvL21vbmFjby1lZGl0b3IvbW9uYXJjaC5odG1sXHJcbiAqICogRWxpeGlyIGxleGVyIC0gaHR0cHM6Ly9naXRodWIuY29tL2VsaXhpci1tYWtldXAvbWFrZXVwX2VsaXhpci9ibG9iL21hc3Rlci9saWIvbWFrZXVwL2xleGVycy9lbGl4aXJfbGV4ZXIuZXhcclxuICogKiBUZXh0TWF0ZSBsZXhlciAoZWxpeGlyLXRtYnVuZGxlKSAtIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGl4aXItZWRpdG9ycy9lbGl4aXItdG1idW5kbGUvYmxvYi9tYXN0ZXIvU3ludGF4ZXMvRWxpeGlyLnRtTGFuZ3VhZ2VcclxuICogKiBUZXh0TWF0ZSBsZXhlciAodnNjb2RlLWVsaXhpci1scykgLSBodHRwczovL2dpdGh1Yi5jb20vZWxpeGlyLWxzcC92c2NvZGUtZWxpeGlyLWxzL2Jsb2IvbWFzdGVyL3N5bnRheGVzL2VsaXhpci5qc29uXHJcbiAqL1xyXG5leHBvcnQgdmFyIGxhbmd1YWdlID0ge1xyXG4gICAgZGVmYXVsdFRva2VuOiAnc291cmNlJyxcclxuICAgIHRva2VuUG9zdGZpeDogJy5lbGl4aXInLFxyXG4gICAgYnJhY2tldHM6IFtcclxuICAgICAgICB7IG9wZW46ICdbJywgY2xvc2U6ICddJywgdG9rZW46ICdkZWxpbWl0ZXIuc3F1YXJlJyB9LFxyXG4gICAgICAgIHsgb3BlbjogJygnLCBjbG9zZTogJyknLCB0b2tlbjogJ2RlbGltaXRlci5wYXJlbnRoZXNpcycgfSxcclxuICAgICAgICB7IG9wZW46ICd7JywgY2xvc2U6ICd9JywgdG9rZW46ICdkZWxpbWl0ZXIuY3VybHknIH0sXHJcbiAgICAgICAgeyBvcGVuOiAnPDwnLCBjbG9zZTogJz4+JywgdG9rZW46ICdkZWxpbWl0ZXIuYW5nbGUuc3BlY2lhbCcgfVxyXG4gICAgXSxcclxuICAgIC8vIEJlbG93IGFyZSBsaXN0cy9yZWdleHBzIHRvIHdoaWNoIHdlIHJlZmVyZW5jZSBsYXRlci5cclxuICAgIGRlY2xhcmF0aW9uS2V5d29yZHM6IFtcclxuICAgICAgICAnZGVmJyxcclxuICAgICAgICAnZGVmcCcsXHJcbiAgICAgICAgJ2RlZm4nLFxyXG4gICAgICAgICdkZWZucCcsXHJcbiAgICAgICAgJ2RlZmd1YXJkJyxcclxuICAgICAgICAnZGVmZ3VhcmRwJyxcclxuICAgICAgICAnZGVmbWFjcm8nLFxyXG4gICAgICAgICdkZWZtYWNyb3AnLFxyXG4gICAgICAgICdkZWZkZWxlZ2F0ZScsXHJcbiAgICAgICAgJ2RlZmNhbGxiYWNrJyxcclxuICAgICAgICAnZGVmbWFjcm9jYWxsYmFjaycsXHJcbiAgICAgICAgJ2RlZm1vZHVsZScsXHJcbiAgICAgICAgJ2RlZnByb3RvY29sJyxcclxuICAgICAgICAnZGVmZXhjZXB0aW9uJyxcclxuICAgICAgICAnZGVmaW1wbCcsXHJcbiAgICAgICAgJ2RlZnN0cnVjdCdcclxuICAgIF0sXHJcbiAgICBvcGVyYXRvcktleXdvcmRzOiBbJ2FuZCcsICdpbicsICdub3QnLCAnb3InLCAnd2hlbiddLFxyXG4gICAgbmFtZXNwYWNlS2V5d29yZHM6IFsnYWxpYXMnLCAnaW1wb3J0JywgJ3JlcXVpcmUnLCAndXNlJ10sXHJcbiAgICBvdGhlcktleXdvcmRzOiBbXHJcbiAgICAgICAgJ2FmdGVyJyxcclxuICAgICAgICAnY2FzZScsXHJcbiAgICAgICAgJ2NhdGNoJyxcclxuICAgICAgICAnY29uZCcsXHJcbiAgICAgICAgJ2RvJyxcclxuICAgICAgICAnZWxzZScsXHJcbiAgICAgICAgJ2VuZCcsXHJcbiAgICAgICAgJ2ZuJyxcclxuICAgICAgICAnZm9yJyxcclxuICAgICAgICAnaWYnLFxyXG4gICAgICAgICdxdW90ZScsXHJcbiAgICAgICAgJ3JhaXNlJyxcclxuICAgICAgICAncmVjZWl2ZScsXHJcbiAgICAgICAgJ3Jlc2N1ZScsXHJcbiAgICAgICAgJ3N1cGVyJyxcclxuICAgICAgICAndGhyb3cnLFxyXG4gICAgICAgICd0cnknLFxyXG4gICAgICAgICd1bmxlc3MnLFxyXG4gICAgICAgICd1bnF1b3RlX3NwbGljaW5nJyxcclxuICAgICAgICAndW5xdW90ZScsXHJcbiAgICAgICAgJ3dpdGgnXHJcbiAgICBdLFxyXG4gICAgY29uc3RhbnRzOiBbJ3RydWUnLCAnZmFsc2UnLCAnbmlsJ10sXHJcbiAgICBuYW1lQnVpbHRpbjogWydfX01PRFVMRV9fJywgJ19fRElSX18nLCAnX19FTlZfXycsICdfX0NBTExFUl9fJywgJ19fU1RBQ0tUUkFDRV9fJ10sXHJcbiAgICAvLyBNYXRjaGVzIGFueSBvZiB0aGUgb3BlcmF0b3IgbmFtZXM6XHJcbiAgICAvLyA8PDwgPj4+IHx8fCAmJiYgXl5eIH5+fiA9PT0gIT09IH4+PiA8fj4gfH4+IDx8PiA9PSAhPSA8PSA+PSAmJiB8fCBcXFxcIDw+ICsrIC0tIHw+ID1+IC0+IDwtIH4+IDx+IDo6IC4uID0gPCA+ICsgLSAqIC8gfCAuIF4gJiAhXHJcbiAgICBvcGVyYXRvcjogLy1bLT5dP3whPXswLDJ9fFxcKnxcXC98XFxcXFxcXFx8JnsxLDN9fFxcLlxcLj98XFxeKD86XFxeXFxeKT98XFwrXFwrP3w8KD86LXw8PHw9fD58XFx8Pnx+Pj8pP3w9fnw9ezEsM318Pig/Oj18Pj4pP3xcXHx+PnxcXHw+fFxcfHsxLDN9fH4+Pj98fn5+fDo6LyxcclxuICAgIC8vIFNlZSBodHRwczovL2hleGRvY3MucG0vZWxpeGlyL3N5bnRheC1yZWZlcmVuY2UuaHRtbCN2YXJpYWJsZXNcclxuICAgIHZhcmlhYmxlTmFtZTogL1thLXpfXVthLXpBLVowLTlfXSpbPyFdPy8sXHJcbiAgICAvLyBTZWUgaHR0cHM6Ly9oZXhkb2NzLnBtL2VsaXhpci9zeW50YXgtcmVmZXJlbmNlLmh0bWwjYXRvbXNcclxuICAgIGF0b21OYW1lOiAvW2EtekEtWl9dW2EtekEtWjAtOV9AXSpbPyFdP3xAc3BlY2lhbEF0b21OYW1lfEBvcGVyYXRvci8sXHJcbiAgICBzcGVjaWFsQXRvbU5hbWU6IC9cXC5cXC5cXC58PDw+PnwlXFx7XFx9fCV8XFx7XFx9LyxcclxuICAgIGFsaWFzUGFydDogL1tBLVpdW2EtekEtWjAtOV9dKi8sXHJcbiAgICBtb2R1bGVOYW1lOiAvQGFsaWFzUGFydCg/OlxcLkBhbGlhc1BhcnQpKi8sXHJcbiAgICAvLyBTaWdpbCBwYWlycyBhcmU6IFwiXCJcIiBcIlwiXCIsICcnJyAnJycsIFwiIFwiLCAnICcsIC8gLywgfCB8LCA8ID4sIHsgfSwgWyBdLCAoIClcclxuICAgIHNpZ2lsU3ltbWV0cmljRGVsaW1pdGVyOiAvXCJcIlwifCcnJ3xcInwnfFxcL3xcXHwvLFxyXG4gICAgc2lnaWxTdGFydERlbGltaXRlcjogL0BzaWdpbFN5bW1ldHJpY0RlbGltaXRlcnw8fFxce3xcXFt8XFwoLyxcclxuICAgIHNpZ2lsRW5kRGVsaW1pdGVyOiAvQHNpZ2lsU3ltbWV0cmljRGVsaW1pdGVyfD58XFx9fFxcXXxcXCkvLFxyXG4gICAgZGVjaW1hbDogL1xcZCg/Ol8/XFxkKSovLFxyXG4gICAgaGV4OiAvWzAtOWEtZkEtRl0oXz9bMC05YS1mQS1GXSkqLyxcclxuICAgIG9jdGFsOiAvWzAtN10oXz9bMC03XSkqLyxcclxuICAgIGJpbmFyeTogL1swMV0oXz9bMDFdKSovLFxyXG4gICAgLy8gU2VlIGh0dHBzOi8vaGV4ZG9jcy5wbS9lbGl4aXIvbWFzdGVyL1N0cmluZy5odG1sI21vZHVsZS1lc2NhcGUtY2hhcmFjdGVyc1xyXG4gICAgZXNjYXBlOiAvXFxcXHVbMC05YS1mQS1GXXs0fXxcXFxceFswLTlhLWZBLUZdezJ9fFxcXFwuLyxcclxuICAgIC8vIFRoZSBrZXlzIGJlbG93IGNvcnJlc3BvbmQgdG8gdG9rZW5pemVyIHN0YXRlcy5cclxuICAgIC8vIFdlIHN0YXJ0IGZyb20gdGhlIHJvb3Qgc3RhdGUgYW5kIG1hdGNoIGFnYWluc3QgaXRzIHJ1bGVzXHJcbiAgICAvLyB1bnRpbCB3ZSBleHBsaWNpdGx5IHRyYW5zaXRpb24gaW50byBhbm90aGVyIHN0YXRlLlxyXG4gICAgLy8gVGhlIGBpbmNsdWRlYCBzaW1wbHkgYnJpbmdzIGluIGFsbCBvcGVyYXRpb25zIGZyb20gdGhlIGdpdmVuIHN0YXRlXHJcbiAgICAvLyBhbmQgaXMgdXNlZnVsIGZvciBpbXByb3ZpbmcgcmVhZGFiaWxpdHkuXHJcbiAgICB0b2tlbml6ZXI6IHtcclxuICAgICAgICByb290OiBbXHJcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0B3aGl0ZXNwYWNlJyB9LFxyXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAY29tbWVudHMnIH0sXHJcbiAgICAgICAgICAgIC8vIEtleXdvcmRzIHN0YXJ0IGFzIGVpdGhlciBhbiBpZGVudGlmaWVyIG9yIGEgc3RyaW5nLFxyXG4gICAgICAgICAgICAvLyBidXQgZW5kIHdpdGggYSA6IHNvIGl0J3MgaW1wb3J0YW50IHRvIG1hdGNoIHRoaXMgZmlyc3QuXHJcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BrZXl3b3Jkc1Nob3J0aGFuZCcgfSxcclxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQG51bWJlcnMnIH0sXHJcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BpZGVudGlmaWVycycgfSxcclxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQHN0cmluZ3MnIH0sXHJcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BhdG9tcycgfSxcclxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQHNpZ2lscycgfSxcclxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQGF0dHJpYnV0ZXMnIH0sXHJcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BzeW1ib2xzJyB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICAvLyBXaGl0ZXNwYWNlXHJcbiAgICAgICAgd2hpdGVzcGFjZTogW1svXFxzKy8sICd3aGl0ZSddXSxcclxuICAgICAgICAvLyBDb21tZW50c1xyXG4gICAgICAgIGNvbW1lbnRzOiBbWy8oIykoLiopLywgWydjb21tZW50LnB1bmN0dWF0aW9uJywgJ2NvbW1lbnQnXV1dLFxyXG4gICAgICAgIC8vIEtleXdvcmQgbGlzdCBzaG9ydGhhbmRcclxuICAgICAgICBrZXl3b3Jkc1Nob3J0aGFuZDogW1xyXG4gICAgICAgICAgICBbLyhAYXRvbU5hbWUpKDopLywgWydjb25zdGFudCcsICdjb25zdGFudC5wdW5jdHVhdGlvbiddXSxcclxuICAgICAgICAgICAgLy8gVXNlIHBvc2l0aXZlIGxvb2stYWhlYWQgdG8gZW5zdXJlIHRoZSBzdHJpbmcgaXMgZm9sbG93ZWQgYnkgOlxyXG4gICAgICAgICAgICAvLyBhbmQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYSBrZXl3b3JkLlxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAvXCIoPz0oW15cIl18I1xcey4qP1xcfXxcXFxcXCIpKlwiOikvLFxyXG4gICAgICAgICAgICAgICAgeyB0b2tlbjogJ2NvbnN0YW50LmRlbGltaXRlcicsIG5leHQ6ICdAZG91YmxlUXVvdGVkU3RyaW5nS2V5d29yZCcgfVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAvJyg/PShbXiddfCNcXHsuKj9cXH18XFxcXCcpKic6KS8sXHJcbiAgICAgICAgICAgICAgICB7IHRva2VuOiAnY29uc3RhbnQuZGVsaW1pdGVyJywgbmV4dDogJ0BzaW5nbGVRdW90ZWRTdHJpbmdLZXl3b3JkJyB9XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICBdLFxyXG4gICAgICAgIGRvdWJsZVF1b3RlZFN0cmluZ0tleXdvcmQ6IFtcclxuICAgICAgICAgICAgWy9cIjovLCB7IHRva2VuOiAnY29uc3RhbnQuZGVsaW1pdGVyJywgbmV4dDogJ0Bwb3AnIH1dLFxyXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAc3RyaW5nQ29uc3RhbnRDb250ZW50SW50ZXJwb2wnIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIHNpbmdsZVF1b3RlZFN0cmluZ0tleXdvcmQ6IFtcclxuICAgICAgICAgICAgWy8nOi8sIHsgdG9rZW46ICdjb25zdGFudC5kZWxpbWl0ZXInLCBuZXh0OiAnQHBvcCcgfV0sXHJcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BzdHJpbmdDb25zdGFudENvbnRlbnRJbnRlcnBvbCcgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgLy8gTnVtYmVyc1xyXG4gICAgICAgIG51bWJlcnM6IFtcclxuICAgICAgICAgICAgWy8wYkBiaW5hcnkvLCAnbnVtYmVyLmJpbmFyeSddLFxyXG4gICAgICAgICAgICBbLzBvQG9jdGFsLywgJ251bWJlci5vY3RhbCddLFxyXG4gICAgICAgICAgICBbLzB4QGhleC8sICdudW1iZXIuaGV4J10sXHJcbiAgICAgICAgICAgIFsvQGRlY2ltYWxcXC5AZGVjaW1hbChbZUVdLT9AZGVjaW1hbCk/LywgJ251bWJlci5mbG9hdCddLFxyXG4gICAgICAgICAgICBbL0BkZWNpbWFsLywgJ251bWJlciddXHJcbiAgICAgICAgXSxcclxuICAgICAgICAvLyBJZGVudGlmaWVyc1xyXG4gICAgICAgIGlkZW50aWZpZXJzOiBbXHJcbiAgICAgICAgICAgIC8vIFRva2VuaXplIGlkZW50aWZpZXIgbmFtZSBpbiBmdW5jdGlvbi1saWtlIGRlZmluaXRpb25zLlxyXG4gICAgICAgICAgICAvLyBOb3RlOiBnaXZlbiBgZGVmIGEgKyBiLCBkbzogbmlsYCwgYGFgIGlzIG5vdCBhIGZ1bmN0aW9uIG5hbWUsXHJcbiAgICAgICAgICAgIC8vIHNvIHdlIHVzZSBuZWdhdGl2ZSBsb29rLWFoZWFkIHRvIGVuc3VyZSB0aGVyZSdzIG5vIG9wZXJhdG9yLlxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAvXFxiKGRlZnA/fGRlZm5wP3xkZWZtYWNyb3A/fGRlZmd1YXJkcD98ZGVmZGVsZWdhdGUpKFxccyspKEB2YXJpYWJsZU5hbWUpKD8hXFxzK0BvcGVyYXRvcikvLFxyXG4gICAgICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgICAgICdrZXl3b3JkLmRlY2xhcmF0aW9uJyxcclxuICAgICAgICAgICAgICAgICAgICAnd2hpdGUnLFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZXM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVucXVvdGU6ICdrZXl3b3JkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdAZGVmYXVsdCc6ICdmdW5jdGlvbidcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgLy8gVG9rZW5pemUgZnVuY3Rpb24gY2FsbHNcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgLy8gSW4tc2NvcGUgY2FsbCAtIGFuIGlkZW50aWZpZXIgZm9sbG93ZWQgYnkgKCBvciAuKFxyXG4gICAgICAgICAgICAgICAgLyhAdmFyaWFibGVOYW1lKSg/PVxccypcXC4/XFxzKlxcKCkvLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2VzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRva2VuaXplIGFzIGtleXdvcmQgaW4gY2FzZXMgbGlrZSBgaWYoLi4uLCBkbzogLi4uLCBlbHNlOiAuLi4pYFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQGRlY2xhcmF0aW9uS2V5d29yZHMnOiAna2V5d29yZC5kZWNsYXJhdGlvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdAbmFtZXNwYWNlS2V5d29yZHMnOiAna2V5d29yZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdAb3RoZXJLZXl3b3Jkcyc6ICdrZXl3b3JkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0BkZWZhdWx0JzogJ2Z1bmN0aW9uLmNhbGwnXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAvLyBSZWZlcmVuY2luZyBmdW5jdGlvbiBpbiBhIG1vZHVsZVxyXG4gICAgICAgICAgICAgICAgLyhAbW9kdWxlTmFtZSkoXFxzKikoXFwuKShcXHMqKShAdmFyaWFibGVOYW1lKS8sXHJcbiAgICAgICAgICAgICAgICBbJ3R5cGUuaWRlbnRpZmllcicsICd3aGl0ZScsICdvcGVyYXRvcicsICd3aGl0ZScsICdmdW5jdGlvbi5jYWxsJ11cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgLy8gUmVmZXJlbmNpbmcgZnVuY3Rpb24gaW4gYW4gRXJsYW5nIG1vZHVsZVxyXG4gICAgICAgICAgICAgICAgLyg6KShAYXRvbU5hbWUpKFxccyopKFxcLikoXFxzKikoQHZhcmlhYmxlTmFtZSkvLFxyXG4gICAgICAgICAgICAgICAgWydjb25zdGFudC5wdW5jdHVhdGlvbicsICdjb25zdGFudCcsICd3aGl0ZScsICdvcGVyYXRvcicsICd3aGl0ZScsICdmdW5jdGlvbi5jYWxsJ11cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgLy8gUGlwaW5nIGludG8gYSBmdW5jdGlvbiAodG9rZW5pemVkIHNlcGFyYXRlbHkgYXMgaXQgbWF5IG5vdCBoYXZlIHBhcmVudGhlc2VzKVxyXG4gICAgICAgICAgICAgICAgLyhcXHw+KShcXHMqKShAdmFyaWFibGVOYW1lKS8sXHJcbiAgICAgICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAgICAgJ29wZXJhdG9yJyxcclxuICAgICAgICAgICAgICAgICAgICAnd2hpdGUnLFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZXM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdAb3RoZXJLZXl3b3Jkcyc6ICdrZXl3b3JkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdAZGVmYXVsdCc6ICdmdW5jdGlvbi5jYWxsJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAvLyBGdW5jdGlvbiByZWZlcmVuY2UgcGFzc2VkIHRvIGFub3RoZXIgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgIC8oJikoXFxzKikoQHZhcmlhYmxlTmFtZSkvLFxyXG4gICAgICAgICAgICAgICAgWydvcGVyYXRvcicsICd3aGl0ZScsICdmdW5jdGlvbi5jYWxsJ11cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgLy8gTGFuZ3VhZ2Uga2V5d29yZHMsIGJ1aWx0aW5zLCBjb25zdGFudHMgYW5kIHZhcmlhYmxlc1xyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAvQHZhcmlhYmxlTmFtZS8sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZXM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0BkZWNsYXJhdGlvbktleXdvcmRzJzogJ2tleXdvcmQuZGVjbGFyYXRpb24nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQG9wZXJhdG9yS2V5d29yZHMnOiAna2V5d29yZC5vcGVyYXRvcicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdAbmFtZXNwYWNlS2V5d29yZHMnOiAna2V5d29yZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdAb3RoZXJLZXl3b3Jkcyc6ICdrZXl3b3JkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0Bjb25zdGFudHMnOiAnY29uc3RhbnQubGFuZ3VhZ2UnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQG5hbWVCdWlsdGluJzogJ3ZhcmlhYmxlLmxhbmd1YWdlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ18uKic6ICdjb21tZW50LnVudXNlZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdAZGVmYXVsdCc6ICdpZGVudGlmaWVyJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgLy8gTW9kdWxlIG5hbWVzXHJcbiAgICAgICAgICAgIFsvQG1vZHVsZU5hbWUvLCAndHlwZS5pZGVudGlmaWVyJ11cclxuICAgICAgICBdLFxyXG4gICAgICAgIC8vIFN0cmluZ3NcclxuICAgICAgICBzdHJpbmdzOiBbXHJcbiAgICAgICAgICAgIFsvXCJcIlwiLywgeyB0b2tlbjogJ3N0cmluZy5kZWxpbWl0ZXInLCBuZXh0OiAnQGRvdWJsZVF1b3RlZEhlcmVkb2MnIH1dLFxyXG4gICAgICAgICAgICBbLycnJy8sIHsgdG9rZW46ICdzdHJpbmcuZGVsaW1pdGVyJywgbmV4dDogJ0BzaW5nbGVRdW90ZWRIZXJlZG9jJyB9XSxcclxuICAgICAgICAgICAgWy9cIi8sIHsgdG9rZW46ICdzdHJpbmcuZGVsaW1pdGVyJywgbmV4dDogJ0Bkb3VibGVRdW90ZWRTdHJpbmcnIH1dLFxyXG4gICAgICAgICAgICBbLycvLCB7IHRva2VuOiAnc3RyaW5nLmRlbGltaXRlcicsIG5leHQ6ICdAc2luZ2xlUXVvdGVkU3RyaW5nJyB9XVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgZG91YmxlUXVvdGVkSGVyZWRvYzogW1xyXG4gICAgICAgICAgICBbL1wiXCJcIi8sIHsgdG9rZW46ICdzdHJpbmcuZGVsaW1pdGVyJywgbmV4dDogJ0Bwb3AnIH1dLFxyXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAc3RyaW5nQ29udGVudEludGVycG9sJyB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBzaW5nbGVRdW90ZWRIZXJlZG9jOiBbXHJcbiAgICAgICAgICAgIFsvJycnLywgeyB0b2tlbjogJ3N0cmluZy5kZWxpbWl0ZXInLCBuZXh0OiAnQHBvcCcgfV0sXHJcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BzdHJpbmdDb250ZW50SW50ZXJwb2wnIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIGRvdWJsZVF1b3RlZFN0cmluZzogW1xyXG4gICAgICAgICAgICBbL1wiLywgeyB0b2tlbjogJ3N0cmluZy5kZWxpbWl0ZXInLCBuZXh0OiAnQHBvcCcgfV0sXHJcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BzdHJpbmdDb250ZW50SW50ZXJwb2wnIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIHNpbmdsZVF1b3RlZFN0cmluZzogW1xyXG4gICAgICAgICAgICBbLycvLCB7IHRva2VuOiAnc3RyaW5nLmRlbGltaXRlcicsIG5leHQ6ICdAcG9wJyB9XSxcclxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQHN0cmluZ0NvbnRlbnRJbnRlcnBvbCcgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgLy8gQXRvbXNcclxuICAgICAgICBhdG9tczogW1xyXG4gICAgICAgICAgICBbLyg6KShAYXRvbU5hbWUpLywgWydjb25zdGFudC5wdW5jdHVhdGlvbicsICdjb25zdGFudCddXSxcclxuICAgICAgICAgICAgWy86XCIvLCB7IHRva2VuOiAnY29uc3RhbnQuZGVsaW1pdGVyJywgbmV4dDogJ0Bkb3VibGVRdW90ZWRTdHJpbmdBdG9tJyB9XSxcclxuICAgICAgICAgICAgWy86Jy8sIHsgdG9rZW46ICdjb25zdGFudC5kZWxpbWl0ZXInLCBuZXh0OiAnQHNpbmdsZVF1b3RlZFN0cmluZ0F0b20nIH1dXHJcbiAgICAgICAgXSxcclxuICAgICAgICBkb3VibGVRdW90ZWRTdHJpbmdBdG9tOiBbXHJcbiAgICAgICAgICAgIFsvXCIvLCB7IHRva2VuOiAnY29uc3RhbnQuZGVsaW1pdGVyJywgbmV4dDogJ0Bwb3AnIH1dLFxyXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAc3RyaW5nQ29uc3RhbnRDb250ZW50SW50ZXJwb2wnIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIHNpbmdsZVF1b3RlZFN0cmluZ0F0b206IFtcclxuICAgICAgICAgICAgWy8nLywgeyB0b2tlbjogJ2NvbnN0YW50LmRlbGltaXRlcicsIG5leHQ6ICdAcG9wJyB9XSxcclxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQHN0cmluZ0NvbnN0YW50Q29udGVudEludGVycG9sJyB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICAvLyBTaWdpbHNcclxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9lbGl4aXItbGFuZy5vcmcvZ2V0dGluZy1zdGFydGVkL3NpZ2lscy5odG1sXHJcbiAgICAgICAgLy8gU2lnaWxzIGFsbG93IGZvciB0eXBpbmcgdmFsdWVzIHVzaW5nIHRoZWlyIHRleHR1YWwgcmVwcmVzZW50YXRpb24uXHJcbiAgICAgICAgLy8gQWxsIHNpZ2lscyBzdGFydCB3aXRoIH4gZm9sbG93ZWQgYnkgYSBsZXR0ZXIgaW5kaWNhdGluZyBzaWdpbCB0eXBlXHJcbiAgICAgICAgLy8gYW5kIHRoZW4gYSBkZWxpbWl0ZXIgcGFpciBlbmNsb3NpbmcgdGhlIHRleHR1YWwgcmVwcmVzZW50YXRpb24uXHJcbiAgICAgICAgLy8gT3B0aW9uYWwgbW9kaWZpZXJzIGFyZSBhbGxvd2VkIGFmdGVyIHRoZSBjbG9zaW5nIGRlbGltaXRlci5cclxuICAgICAgICAvLyBGb3IgaW5zdGFuY2UgYSByZWd1bGFyIGV4cHJlc3Npb25zIGNhbiBiZSB3cml0dGVuIGFzOlxyXG4gICAgICAgIC8vIH5yL2Zvb3xiYXIvIH5ye2Zvb3xiYXJ9IH5yL2Zvb3xiYXIvZ1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gSW4gZ2VuZXJhbCBsb3dlcmNhc2Ugc2lnaWxzIGFsbG93IGZvciBpbnRlcnBvbGF0aW9uXHJcbiAgICAgICAgLy8gYW5kIGVzY2FwZWQgY2hhcmFjdGVycywgd2hlcmVhcyB1cHBlcmNhc2Ugc2lnaWxzIGRvbid0XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBEdXJpbmcgdG9rZW5pemF0aW9uIHdlIHdhbnQgdG8gZGlzdGluZ3Vpc2ggc29tZVxyXG4gICAgICAgIC8vIHNwZWNpZmljIHNpZ2lsIHR5cGVzLCBuYW1lbHkgc3RyaW5nIGFuZCByZWdleHAsXHJcbiAgICAgICAgLy8gc28gdGhhdCB0aGV5IGNlbiBiZSB0aGVtZWQgc2VwYXJhdGVseS5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFRvIHJlYXNvbmFibHkgaGFuZGxlIGFsbCB0aG9zZSBjb21iaW5hdGlvbnMgd2UgbGV2ZXJhZ2VcclxuICAgICAgICAvLyBkb3Qtc2VwYXJhdGVkIHN0YXRlcywgc28gaWYgd2UgdHJhbnNpdGlvbiB0byBAc2lnaWxTdGFydC5pbnRlcnBvbC5zLnsufVxyXG4gICAgICAgIC8vIHRoZW4gXCJzaWdpbFN0YXJ0LmludGVycG9sLnNcIiBzdGF0ZSB3aWxsIG1hdGNoIGFuZCBhbHNvIGFsbFxyXG4gICAgICAgIC8vIHRoZSBpbmRpdmlkdWFsIGRvdC1zZXBhcmF0ZWQgcGFyYW1ldGVycyBjYW4gYmUgYWNjZXNzZWQuXHJcbiAgICAgICAgc2lnaWxzOiBbXHJcbiAgICAgICAgICAgIFsvflthLXpdQHNpZ2lsU3RhcnREZWxpbWl0ZXIvLCB7IHRva2VuOiAnQHJlbWF0Y2gnLCBuZXh0OiAnQHNpZ2lsLmludGVycG9sJyB9XSxcclxuICAgICAgICAgICAgWy9+W0EtWl1Ac2lnaWxTdGFydERlbGltaXRlci8sIHsgdG9rZW46ICdAcmVtYXRjaCcsIG5leHQ6ICdAc2lnaWwubm9JbnRlcnBvbCcgfV1cclxuICAgICAgICBdLFxyXG4gICAgICAgIHNpZ2lsOiBbXHJcbiAgICAgICAgICAgIFsvfihbYS16QS1aXSlcXHsvLCB7IHRva2VuOiAnQHJlbWF0Y2gnLCBzd2l0Y2hUbzogJ0BzaWdpbFN0YXJ0LiRTMi4kMS57Ln0nIH1dLFxyXG4gICAgICAgICAgICBbL34oW2EtekEtWl0pXFxbLywgeyB0b2tlbjogJ0ByZW1hdGNoJywgc3dpdGNoVG86ICdAc2lnaWxTdGFydC4kUzIuJDEuWy5dJyB9XSxcclxuICAgICAgICAgICAgWy9+KFthLXpBLVpdKVxcKC8sIHsgdG9rZW46ICdAcmVtYXRjaCcsIHN3aXRjaFRvOiAnQHNpZ2lsU3RhcnQuJFMyLiQxLiguKScgfV0sXHJcbiAgICAgICAgICAgIFsvfihbYS16QS1aXSlcXDwvLCB7IHRva2VuOiAnQHJlbWF0Y2gnLCBzd2l0Y2hUbzogJ0BzaWdpbFN0YXJ0LiRTMi4kMS48Lj4nIH1dLFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAvfihbYS16QS1aXSkoQHNpZ2lsU3ltbWV0cmljRGVsaW1pdGVyKS8sXHJcbiAgICAgICAgICAgICAgICB7IHRva2VuOiAnQHJlbWF0Y2gnLCBzd2l0Y2hUbzogJ0BzaWdpbFN0YXJ0LiRTMi4kMS4kMi4kMicgfVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgXSxcclxuICAgICAgICAvLyBUaGUgZGVmaW5pdGlvbnMgYmVsb3cgZXhwZWN0IHN0YXRlcyB0byBiZSBvZiB0aGUgZm9ybTpcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIHNpZ2lsU3RhcnQuPGludGVycG9sLW9yLW5vSW50ZXJwb2w+LjxzaWdpbC1sZXR0ZXI+LjxzdGFydC1kZWxpbWl0ZXI+LjxlbmQtZGVsaW1pdGVyPlxyXG4gICAgICAgIC8vIHNpZ2lsQ29udGludWUuPGludGVycG9sLW9yLW5vSW50ZXJwb2w+LjxzaWdpbC1sZXR0ZXI+LjxzdGFydC1kZWxpbWl0ZXI+LjxlbmQtZGVsaW1pdGVyPlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gVGhlIHNpZ2lsU3RhcnQgc3RhdGUgaXMgdXNlZCBvbmx5IHRvIHByb3Blcmx5IGNsYXNzaWZ5IHRoZSB0b2tlbiAoYXMgc3RyaW5nL3JlZ2V4L3NpZ2lsKVxyXG4gICAgICAgIC8vIGFuZCBpbW1lZGlhdGVseSBzd2l0Y2hlcyB0byB0aGUgc2lnaWxDb250aW51ZSBzYXRlLCB3aGljaCBoYW5kbGVzIHRoZSBhY3R1YWwgY29udGVudFxyXG4gICAgICAgIC8vIGFuZCB3YWl0cyBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgZW5kIGRlbGltaXRlci5cclxuICAgICAgICAnc2lnaWxTdGFydC5pbnRlcnBvbC5zJzogW1xyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAvfnNAc2lnaWxTdGFydERlbGltaXRlci8sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46ICdzdHJpbmcuZGVsaW1pdGVyJyxcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2hUbzogJ0BzaWdpbENvbnRpbnVlLiRTMi4kUzMuJFM0LiRTNSdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgJ3NpZ2lsQ29udGludWUuaW50ZXJwb2wucyc6IFtcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgLyhAc2lnaWxFbmREZWxpbWl0ZXIpW2EtekEtWl0qLyxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnJDE9PSRTNSc6IHsgdG9rZW46ICdzdHJpbmcuZGVsaW1pdGVyJywgbmV4dDogJ0Bwb3AnIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdAZGVmYXVsdCc6ICdzdHJpbmcnXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAc3RyaW5nQ29udGVudEludGVycG9sJyB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICAnc2lnaWxTdGFydC5ub0ludGVycG9sLlMnOiBbXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIC9+U0BzaWdpbFN0YXJ0RGVsaW1pdGVyLyxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbjogJ3N0cmluZy5kZWxpbWl0ZXInLFxyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaFRvOiAnQHNpZ2lsQ29udGludWUuJFMyLiRTMy4kUzQuJFM1J1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgXSxcclxuICAgICAgICAnc2lnaWxDb250aW51ZS5ub0ludGVycG9sLlMnOiBbXHJcbiAgICAgICAgICAgIC8vIElnbm9yZSBlc2NhcGVkIHNpZ2lsIGVuZFxyXG4gICAgICAgICAgICBbLyhefFteXFxcXF0pXFxcXEBzaWdpbEVuZERlbGltaXRlci8sICdzdHJpbmcnXSxcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgLyhAc2lnaWxFbmREZWxpbWl0ZXIpW2EtekEtWl0qLyxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnJDE9PSRTNSc6IHsgdG9rZW46ICdzdHJpbmcuZGVsaW1pdGVyJywgbmV4dDogJ0Bwb3AnIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdAZGVmYXVsdCc6ICdzdHJpbmcnXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAc3RyaW5nQ29udGVudCcgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgJ3NpZ2lsU3RhcnQuaW50ZXJwb2wucic6IFtcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgL35yQHNpZ2lsU3RhcnREZWxpbWl0ZXIvLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiAncmVnZXhwLmRlbGltaXRlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoVG86ICdAc2lnaWxDb250aW51ZS4kUzIuJFMzLiRTNC4kUzUnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICBdLFxyXG4gICAgICAgICdzaWdpbENvbnRpbnVlLmludGVycG9sLnInOiBbXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIC8oQHNpZ2lsRW5kRGVsaW1pdGVyKVthLXpBLVpdKi8sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZXM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJyQxPT0kUzUnOiB7IHRva2VuOiAncmVnZXhwLmRlbGltaXRlcicsIG5leHQ6ICdAcG9wJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQGRlZmF1bHQnOiAncmVnZXhwJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQHJlZ2V4cENvbnRlbnRJbnRlcnBvbCcgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgJ3NpZ2lsU3RhcnQubm9JbnRlcnBvbC5SJzogW1xyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAvflJAc2lnaWxTdGFydERlbGltaXRlci8sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46ICdyZWdleHAuZGVsaW1pdGVyJyxcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2hUbzogJ0BzaWdpbENvbnRpbnVlLiRTMi4kUzMuJFM0LiRTNSdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgJ3NpZ2lsQ29udGludWUubm9JbnRlcnBvbC5SJzogW1xyXG4gICAgICAgICAgICAvLyBJZ25vcmUgZXNjYXBlZCBzaWdpbCBlbmRcclxuICAgICAgICAgICAgWy8oXnxbXlxcXFxdKVxcXFxAc2lnaWxFbmREZWxpbWl0ZXIvLCAncmVnZXhwJ10sXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIC8oQHNpZ2lsRW5kRGVsaW1pdGVyKVthLXpBLVpdKi8sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZXM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJyQxPT0kUzUnOiB7IHRva2VuOiAncmVnZXhwLmRlbGltaXRlcicsIG5leHQ6ICdAcG9wJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQGRlZmF1bHQnOiAncmVnZXhwJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQHJlZ2V4cENvbnRlbnQnIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIHRoZSBnZW5lcmljIHNpZ2lsIGJ5IGRlZmF1bHRcclxuICAgICAgICAnc2lnaWxTdGFydC5pbnRlcnBvbCc6IFtcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgL34oW2EtekEtWl0pQHNpZ2lsU3RhcnREZWxpbWl0ZXIvLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiAnc2lnaWwuZGVsaW1pdGVyJyxcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2hUbzogJ0BzaWdpbENvbnRpbnVlLiRTMi4kUzMuJFM0LiRTNSdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgJ3NpZ2lsQ29udGludWUuaW50ZXJwb2wnOiBbXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIC8oQHNpZ2lsRW5kRGVsaW1pdGVyKVthLXpBLVpdKi8sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZXM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJyQxPT0kUzUnOiB7IHRva2VuOiAnc2lnaWwuZGVsaW1pdGVyJywgbmV4dDogJ0Bwb3AnIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdAZGVmYXVsdCc6ICdzaWdpbCdcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BzaWdpbENvbnRlbnRJbnRlcnBvbCcgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgJ3NpZ2lsU3RhcnQubm9JbnRlcnBvbCc6IFtcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgL34oW2EtekEtWl0pQHNpZ2lsU3RhcnREZWxpbWl0ZXIvLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiAnc2lnaWwuZGVsaW1pdGVyJyxcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2hUbzogJ0BzaWdpbENvbnRpbnVlLiRTMi4kUzMuJFM0LiRTNSdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgJ3NpZ2lsQ29udGludWUubm9JbnRlcnBvbCc6IFtcclxuICAgICAgICAgICAgLy8gSWdub3JlIGVzY2FwZWQgc2lnaWwgZW5kXHJcbiAgICAgICAgICAgIFsvKF58W15cXFxcXSlcXFxcQHNpZ2lsRW5kRGVsaW1pdGVyLywgJ3NpZ2lsJ10sXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIC8oQHNpZ2lsRW5kRGVsaW1pdGVyKVthLXpBLVpdKi8sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZXM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJyQxPT0kUzUnOiB7IHRva2VuOiAnc2lnaWwuZGVsaW1pdGVyJywgbmV4dDogJ0Bwb3AnIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdAZGVmYXVsdCc6ICdzaWdpbCdcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BzaWdpbENvbnRlbnQnIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIC8vIEF0dHJpYnV0ZXNcclxuICAgICAgICBhdHRyaWJ1dGVzOiBbXHJcbiAgICAgICAgICAgIC8vIE1vZHVsZSBAZG9jKiBhdHRyaWJ1dGVzIC0gdG9rZW5pemVkIGFzIGNvbW1lbnRzXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIC9cXEAobW9kdWxlfHR5cGUpP2RvYyAofltzU10pP1wiXCJcIi8sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46ICdjb21tZW50LmJsb2NrLmRvY3VtZW50YXRpb24nLFxyXG4gICAgICAgICAgICAgICAgICAgIG5leHQ6ICdAZG91YmxlUXVvdGVkSGVyZWRvY0RvY3N0cmluZydcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgL1xcQChtb2R1bGV8dHlwZSk/ZG9jICh+W3NTXSk/XCIvLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiAnY29tbWVudC5ibG9jay5kb2N1bWVudGF0aW9uJyxcclxuICAgICAgICAgICAgICAgICAgICBuZXh0OiAnQGRvdWJsZVF1b3RlZFN0cmluZ0RvY3N0cmluZydcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgWy9cXEAobW9kdWxlfHR5cGUpP2RvYyBmYWxzZS8sICdjb21tZW50LmJsb2NrLmRvY3VtZW50YXRpb24nXSxcclxuICAgICAgICAgICAgLy8gTW9kdWxlIGF0dHJpYnV0ZXNcclxuICAgICAgICAgICAgWy9cXEAoQHZhcmlhYmxlTmFtZSkvLCAndmFyaWFibGUnXVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgZG91YmxlUXVvdGVkSGVyZWRvY0RvY3N0cmluZzogW1xyXG4gICAgICAgICAgICBbL1wiXCJcIi8sIHsgdG9rZW46ICdjb21tZW50LmJsb2NrLmRvY3VtZW50YXRpb24nLCBuZXh0OiAnQHBvcCcgfV0sXHJcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0Bkb2NzdHJpbmdDb250ZW50JyB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBkb3VibGVRdW90ZWRTdHJpbmdEb2NzdHJpbmc6IFtcclxuICAgICAgICAgICAgWy9cIi8sIHsgdG9rZW46ICdjb21tZW50LmJsb2NrLmRvY3VtZW50YXRpb24nLCBuZXh0OiAnQHBvcCcgfV0sXHJcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0Bkb2NzdHJpbmdDb250ZW50JyB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICAvLyBPcGVyYXRvcnMsIHB1bmN0dWF0aW9uLCBicmFja2V0c1xyXG4gICAgICAgIHN5bWJvbHM6IFtcclxuICAgICAgICAgICAgLy8gQ29kZSBwb2ludCBvcGVyYXRvciAoZWl0aGVyIHdpdGggcmVndWxhciBjaGFyYWN0ZXIgP2Egb3IgYW4gZXNjYXBlZCBvbmUgP1xcbilcclxuICAgICAgICAgICAgWy9cXD8oXFxcXC58W15cXFxcXFxzXSkvLCAnbnVtYmVyLmNvbnN0YW50J10sXHJcbiAgICAgICAgICAgIC8vIEFub255bW91cyBmdW5jdGlvbiBhcmd1bWVudHNcclxuICAgICAgICAgICAgWy8mXFxkKy8sICdvcGVyYXRvciddLFxyXG4gICAgICAgICAgICAvLyBCaXRzaGlmdCBvcGVyYXRvcnMgKG11c3QgZ28gYmVmb3JlIGRlbGltaXRlcnMsIHNvIHRoYXQgPDwgPj4gZG9uJ3QgbWF0Y2ggZmlyc3QpXHJcbiAgICAgICAgICAgIFsvPDw8fD4+Pi8sICdvcGVyYXRvciddLFxyXG4gICAgICAgICAgICAvLyBEZWxpbWl0ZXIgcGFpcnNcclxuICAgICAgICAgICAgWy9bKClcXFtcXF1cXHtcXH1dfDw8fD4+LywgJ0BicmFja2V0cyddLFxyXG4gICAgICAgICAgICAvLyBUcmlwbGUgZG90IGlzIGEgdmFsaWQgbmFtZSAobXVzdCBnbyBiZWZvcmUgb3BlcmF0b3JzLCBzbyB0aGF0IC4uIGRvZXNuJ3QgbWF0Y2ggaW5zdGVhZClcclxuICAgICAgICAgICAgWy9cXC5cXC5cXC4vLCAnaWRlbnRpZmllciddLFxyXG4gICAgICAgICAgICAvLyBQdW5jdHVhdGlvbiA9PiAobXVzdCBnbyBiZWZvcmUgb3BlcmF0b3JzLCBzbyBpdCdzIG5vdCB0b2tlbml6ZWQgYXMgPSB0aGVuID4pXHJcbiAgICAgICAgICAgIFsvPT4vLCAncHVuY3R1YXRpb24nXSxcclxuICAgICAgICAgICAgLy8gT3BlcmF0b3JzXHJcbiAgICAgICAgICAgIFsvQG9wZXJhdG9yLywgJ29wZXJhdG9yJ10sXHJcbiAgICAgICAgICAgIC8vIFB1bmN0dWF0aW9uXHJcbiAgICAgICAgICAgIFsvWzo7LC4lXS8sICdwdW5jdHVhdGlvbiddXHJcbiAgICAgICAgXSxcclxuICAgICAgICAvLyBHZW5lcmljIGhlbHBlcnNcclxuICAgICAgICBzdHJpbmdDb250ZW50SW50ZXJwb2w6IFtcclxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQGludGVycG9sYXRpb24nIH0sXHJcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0Blc2NhcGVDaGFyJyB9LFxyXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAc3RyaW5nQ29udGVudCcgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgc3RyaW5nQ29udGVudDogW1svLi8sICdzdHJpbmcnXV0sXHJcbiAgICAgICAgc3RyaW5nQ29uc3RhbnRDb250ZW50SW50ZXJwb2w6IFtcclxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQGludGVycG9sYXRpb24nIH0sXHJcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0Blc2NhcGVDaGFyJyB9LFxyXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAc3RyaW5nQ29uc3RhbnRDb250ZW50JyB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBzdHJpbmdDb25zdGFudENvbnRlbnQ6IFtbLy4vLCAnY29uc3RhbnQnXV0sXHJcbiAgICAgICAgcmVnZXhwQ29udGVudEludGVycG9sOiBbXHJcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BpbnRlcnBvbGF0aW9uJyB9LFxyXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAZXNjYXBlQ2hhcicgfSxcclxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQHJlZ2V4cENvbnRlbnQnIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIHJlZ2V4cENvbnRlbnQ6IFtcclxuICAgICAgICAgICAgLy8gIyBtYXkgYmUgYSByZWd1bGFyIHJlZ2V4cCBjaGFyLCBzbyB3ZSB1c2UgYSBoZXVyaXN0aWNcclxuICAgICAgICAgICAgLy8gYXNzdW1pbmcgYSAjIHN1cnJvdW5kZWQgYnkgd2hpdGVzcGFjZSBpcyBhY3R1YWxseSBhIGNvbW1lbnQuXHJcbiAgICAgICAgICAgIFsvKFxccykoIykoXFxzLiopJC8sIFsnd2hpdGUnLCAnY29tbWVudC5wdW5jdHVhdGlvbicsICdjb21tZW50J11dLFxyXG4gICAgICAgICAgICBbLy4vLCAncmVnZXhwJ11cclxuICAgICAgICBdLFxyXG4gICAgICAgIHNpZ2lsQ29udGVudEludGVycG9sOiBbXHJcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0BpbnRlcnBvbGF0aW9uJyB9LFxyXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAZXNjYXBlQ2hhcicgfSxcclxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQHNpZ2lsQ29udGVudCcgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgc2lnaWxDb250ZW50OiBbWy8uLywgJ3NpZ2lsJ11dLFxyXG4gICAgICAgIGRvY3N0cmluZ0NvbnRlbnQ6IFtbLy4vLCAnY29tbWVudC5ibG9jay5kb2N1bWVudGF0aW9uJ11dLFxyXG4gICAgICAgIGVzY2FwZUNoYXI6IFtbL0Blc2NhcGUvLCAnY29uc3RhbnQuY2hhcmFjdGVyLmVzY2FwZSddXSxcclxuICAgICAgICBpbnRlcnBvbGF0aW9uOiBbXHJcbiAgICAgICAgICAgIFsvI3svLCB7IHRva2VuOiAnZGVsaW1pdGVyLmJyYWNrZXQuZW1iZWQnLCBuZXh0OiAnQGludGVycG9sYXRpb25Db250aW51ZScgfV1cclxuICAgICAgICBdLFxyXG4gICAgICAgIGludGVycG9sYXRpb25Db250aW51ZTogW1xyXG4gICAgICAgICAgICBbL30vLCB7IHRva2VuOiAnZGVsaW1pdGVyLmJyYWNrZXQuZW1iZWQnLCBuZXh0OiAnQHBvcCcgfV0sXHJcbiAgICAgICAgICAgIC8vIEludGVycG9sYXRpb24gYnJhY2tldHMgbWF5IGNvbnRhaW4gYXJiaXRyYXJ5IGNvZGUsXHJcbiAgICAgICAgICAgIC8vIHNvIHdlIHNpbXBseSBtYXRjaCBhZ2FpbnN0IGFsbCB0aGUgcm9vdCBydWxlcyxcclxuICAgICAgICAgICAgLy8gdW50aWwgd2UgcmVhY2ggaW50ZXJwb2xhdGlvbiBlbmQgKHRoZSBhYm92ZSBtYXRjaGVzKS5cclxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQHJvb3QnIH1cclxuICAgICAgICBdXHJcbiAgICB9XHJcbn07XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=