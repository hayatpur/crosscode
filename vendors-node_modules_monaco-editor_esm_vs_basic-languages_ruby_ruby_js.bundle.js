(self["webpackChunkcross_code"] = self["webpackChunkcross_code"] || []).push([["vendors-node_modules_monaco-editor_esm_vs_basic-languages_ruby_ruby_js"],{

/***/ "./node_modules/monaco-editor/esm/vs/basic-languages/ruby/ruby.js":
/*!************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/basic-languages/ruby/ruby.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "conf": () => (/* binding */ conf),
/* harmony export */   "language": () => (/* binding */ language)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var conf = {
    comments: {
        lineComment: '#',
        blockComment: ['=begin', '=end']
    },
    brackets: [
        ['(', ')'],
        ['{', '}'],
        ['[', ']']
    ],
    autoClosingPairs: [
        { open: '{', close: '}' },
        { open: '[', close: ']' },
        { open: '(', close: ')' },
        { open: '"', close: '"' },
        { open: "'", close: "'" }
    ],
    surroundingPairs: [
        { open: '{', close: '}' },
        { open: '[', close: ']' },
        { open: '(', close: ')' },
        { open: '"', close: '"' },
        { open: "'", close: "'" }
    ],
    indentationRules: {
        increaseIndentPattern: new RegExp('^\\s*((begin|class|(private|protected)\\s+def|def|else|elsif|ensure|for|if|module|rescue|unless|until|when|while|case)|([^#]*\\sdo\\b)|([^#]*=\\s*(case|if|unless)))\\b([^#\\{;]|("|\'|/).*\\4)*(#.*)?$'),
        decreaseIndentPattern: new RegExp('^\\s*([}\\]]([,)]?\\s*(#|$)|\\.[a-zA-Z_]\\w*\\b)|(end|rescue|ensure|else|elsif|when)\\b)')
    }
};
/*
 * Ruby language definition
 *
 * Quite a complex language due to elaborate escape sequences
 * and quoting of literate strings/regular expressions, and
 * an 'end' keyword that does not always apply to modifiers like until and while,
 * and a 'do' keyword that sometimes starts a block, but sometimes is part of
 * another statement (like 'while').
 *
 * (1) end blocks:
 * 'end' may end declarations like if or until, but sometimes 'if' or 'until'
 * are modifiers where there is no 'end'. Also, 'do' sometimes starts a block
 * that is ended by 'end', but sometimes it is part of a 'while', 'for', or 'until'
 * To do proper brace matching we do some elaborate state manipulation.
 * some examples:
 *
 *   until bla do
 *     work until tired
 *     list.each do
 *       something if test
 *     end
 *   end
 *
 * or
 *
 * if test
 *  something (if test then x end)
 *  bar if bla
 * end
 *
 * or, how about using class as a property..
 *
 * class Test
 *   def endpoint
 *     self.class.endpoint || routes
 *   end
 * end
 *
 * (2) quoting:
 * there are many kinds of strings and escape sequences. But also, one can
 * start many string-like things as '%qx' where q specifies the kind of string
 * (like a command, escape expanded, regular expression, symbol etc.), and x is
 * some character and only another 'x' ends the sequence. Except for brackets
 * where the closing bracket ends the sequence.. and except for a nested bracket
 * inside the string like entity. Also, such strings can contain interpolated
 * ruby expressions again (and span multiple lines). Moreover, expanded
 * regular expression can also contain comments.
 */
var language = {
    tokenPostfix: '.ruby',
    keywords: [
        '__LINE__',
        '__ENCODING__',
        '__FILE__',
        'BEGIN',
        'END',
        'alias',
        'and',
        'begin',
        'break',
        'case',
        'class',
        'def',
        'defined?',
        'do',
        'else',
        'elsif',
        'end',
        'ensure',
        'for',
        'false',
        'if',
        'in',
        'module',
        'next',
        'nil',
        'not',
        'or',
        'redo',
        'rescue',
        'retry',
        'return',
        'self',
        'super',
        'then',
        'true',
        'undef',
        'unless',
        'until',
        'when',
        'while',
        'yield'
    ],
    keywordops: ['::', '..', '...', '?', ':', '=>'],
    builtins: [
        'require',
        'public',
        'private',
        'include',
        'extend',
        'attr_reader',
        'protected',
        'private_class_method',
        'protected_class_method',
        'new'
    ],
    // these are closed by 'end' (if, while and until are handled separately)
    declarations: [
        'module',
        'class',
        'def',
        'case',
        'do',
        'begin',
        'for',
        'if',
        'while',
        'until',
        'unless'
    ],
    linedecls: ['def', 'case', 'do', 'begin', 'for', 'if', 'while', 'until', 'unless'],
    operators: [
        '^',
        '&',
        '|',
        '<=>',
        '==',
        '===',
        '!~',
        '=~',
        '>',
        '>=',
        '<',
        '<=',
        '<<',
        '>>',
        '+',
        '-',
        '*',
        '/',
        '%',
        '**',
        '~',
        '+@',
        '-@',
        '[]',
        '[]=',
        '`',
        '+=',
        '-=',
        '*=',
        '**=',
        '/=',
        '^=',
        '%=',
        '<<=',
        '>>=',
        '&=',
        '&&=',
        '||=',
        '|='
    ],
    brackets: [
        { open: '(', close: ')', token: 'delimiter.parenthesis' },
        { open: '{', close: '}', token: 'delimiter.curly' },
        { open: '[', close: ']', token: 'delimiter.square' }
    ],
    // we include these common regular expressions
    symbols: /[=><!~?:&|+\-*\/\^%\.]+/,
    // escape sequences
    escape: /(?:[abefnrstv\\"'\n\r]|[0-7]{1,3}|x[0-9A-Fa-f]{1,2}|u[0-9A-Fa-f]{4})/,
    escapes: /\\(?:C\-(@escape|.)|c(@escape|.)|@escape)/,
    decpart: /\d(_?\d)*/,
    decimal: /0|@decpart/,
    delim: /[^a-zA-Z0-9\s\n\r]/,
    heredelim: /(?:\w+|'[^']*'|"[^"]*"|`[^`]*`)/,
    regexpctl: /[(){}\[\]\$\^|\-*+?\.]/,
    regexpesc: /\\(?:[AzZbBdDfnrstvwWn0\\\/]|@regexpctl|c[A-Z]|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4})?/,
    // The main tokenizer for our languages
    tokenizer: {
        // Main entry.
        // root.<decl> where decl is the current opening declaration (like 'class')
        root: [
            // identifiers and keywords
            // most complexity here is due to matching 'end' correctly with declarations.
            // We distinguish a declaration that comes first on a line, versus declarations further on a line (which are most likey modifiers)
            [
                /^(\s*)([a-z_]\w*[!?=]?)/,
                [
                    'white',
                    {
                        cases: {
                            'for|until|while': {
                                token: 'keyword.$2',
                                next: '@dodecl.$2'
                            },
                            '@declarations': {
                                token: 'keyword.$2',
                                next: '@root.$2'
                            },
                            end: { token: 'keyword.$S2', next: '@pop' },
                            '@keywords': 'keyword',
                            '@builtins': 'predefined',
                            '@default': 'identifier'
                        }
                    }
                ]
            ],
            [
                /[a-z_]\w*[!?=]?/,
                {
                    cases: {
                        'if|unless|while|until': {
                            token: 'keyword.$0x',
                            next: '@modifier.$0x'
                        },
                        for: { token: 'keyword.$2', next: '@dodecl.$2' },
                        '@linedecls': { token: 'keyword.$0', next: '@root.$0' },
                        end: { token: 'keyword.$S2', next: '@pop' },
                        '@keywords': 'keyword',
                        '@builtins': 'predefined',
                        '@default': 'identifier'
                    }
                }
            ],
            [/[A-Z][\w]*[!?=]?/, 'constructor.identifier'],
            [/\$[\w]*/, 'global.constant'],
            [/@[\w]*/, 'namespace.instance.identifier'],
            [/@@@[\w]*/, 'namespace.class.identifier'],
            // here document
            [/<<[-~](@heredelim).*/, { token: 'string.heredoc.delimiter', next: '@heredoc.$1' }],
            [
                /[ \t\r\n]+<<(@heredelim).*/,
                { token: 'string.heredoc.delimiter', next: '@heredoc.$1' }
            ],
            [/^<<(@heredelim).*/, { token: 'string.heredoc.delimiter', next: '@heredoc.$1' }],
            // whitespace
            { include: '@whitespace' },
            // strings
            [/"/, { token: 'string.d.delim', next: '@dstring.d."' }],
            [/'/, { token: 'string.sq.delim', next: '@sstring.sq' }],
            // % literals. For efficiency, rematch in the 'pstring' state
            [/%([rsqxwW]|Q?)/, { token: '@rematch', next: 'pstring' }],
            // commands and symbols
            [/`/, { token: 'string.x.delim', next: '@dstring.x.`' }],
            [/:(\w|[$@])\w*[!?=]?/, 'string.s'],
            [/:"/, { token: 'string.s.delim', next: '@dstring.s."' }],
            [/:'/, { token: 'string.s.delim', next: '@sstring.s' }],
            // regular expressions. Lookahead for a (not escaped) closing forwardslash on the same line
            [/\/(?=(\\\/|[^\/\n])+\/)/, { token: 'regexp.delim', next: '@regexp' }],
            // delimiters and operators
            [/[{}()\[\]]/, '@brackets'],
            [
                /@symbols/,
                {
                    cases: {
                        '@keywordops': 'keyword',
                        '@operators': 'operator',
                        '@default': ''
                    }
                }
            ],
            [/[;,]/, 'delimiter'],
            // numbers
            [/0[xX][0-9a-fA-F](_?[0-9a-fA-F])*/, 'number.hex'],
            [/0[_oO][0-7](_?[0-7])*/, 'number.octal'],
            [/0[bB][01](_?[01])*/, 'number.binary'],
            [/0[dD]@decpart/, 'number'],
            [
                /@decimal((\.@decpart)?([eE][\-+]?@decpart)?)/,
                {
                    cases: {
                        $1: 'number.float',
                        '@default': 'number'
                    }
                }
            ]
        ],
        // used to not treat a 'do' as a block opener if it occurs on the same
        // line as a 'do' statement: 'while|until|for'
        // dodecl.<decl> where decl is the declarations started, like 'while'
        dodecl: [
            [/^/, { token: '', switchTo: '@root.$S2' }],
            [
                /[a-z_]\w*[!?=]?/,
                {
                    cases: {
                        end: { token: 'keyword.$S2', next: '@pop' },
                        do: { token: 'keyword', switchTo: '@root.$S2' },
                        '@linedecls': {
                            token: '@rematch',
                            switchTo: '@root.$S2'
                        },
                        '@keywords': 'keyword',
                        '@builtins': 'predefined',
                        '@default': 'identifier'
                    }
                }
            ],
            { include: '@root' }
        ],
        // used to prevent potential modifiers ('if|until|while|unless') to match
        // with 'end' keywords.
        // modifier.<decl>x where decl is the declaration starter, like 'if'
        modifier: [
            [/^/, '', '@pop'],
            [
                /[a-z_]\w*[!?=]?/,
                {
                    cases: {
                        end: { token: 'keyword.$S2', next: '@pop' },
                        'then|else|elsif|do': {
                            token: 'keyword',
                            switchTo: '@root.$S2'
                        },
                        '@linedecls': {
                            token: '@rematch',
                            switchTo: '@root.$S2'
                        },
                        '@keywords': 'keyword',
                        '@builtins': 'predefined',
                        '@default': 'identifier'
                    }
                }
            ],
            { include: '@root' }
        ],
        // single quote strings (also used for symbols)
        // sstring.<kind>  where kind is 'sq' (single quote) or 's' (symbol)
        sstring: [
            [/[^\\']+/, 'string.$S2'],
            [/\\\\|\\'|\\$/, 'string.$S2.escape'],
            [/\\./, 'string.$S2.invalid'],
            [/'/, { token: 'string.$S2.delim', next: '@pop' }]
        ],
        // double quoted "string".
        // dstring.<kind>.<delim> where kind is 'd' (double quoted), 'x' (command), or 's' (symbol)
        // and delim is the ending delimiter (" or `)
        dstring: [
            [/[^\\`"#]+/, 'string.$S2'],
            [/#/, 'string.$S2.escape', '@interpolated'],
            [/\\$/, 'string.$S2.escape'],
            [/@escapes/, 'string.$S2.escape'],
            [/\\./, 'string.$S2.escape.invalid'],
            [
                /[`"]/,
                {
                    cases: {
                        '$#==$S3': { token: 'string.$S2.delim', next: '@pop' },
                        '@default': 'string.$S2'
                    }
                }
            ]
        ],
        // literal documents
        // heredoc.<close> where close is the closing delimiter
        heredoc: [
            [
                /^(\s*)(@heredelim)$/,
                {
                    cases: {
                        '$2==$S2': [
                            'string.heredoc',
                            { token: 'string.heredoc.delimiter', next: '@pop' }
                        ],
                        '@default': ['string.heredoc', 'string.heredoc']
                    }
                }
            ],
            [/.*/, 'string.heredoc']
        ],
        // interpolated sequence
        interpolated: [
            [/\$\w*/, 'global.constant', '@pop'],
            [/@\w*/, 'namespace.class.identifier', '@pop'],
            [/@@@\w*/, 'namespace.instance.identifier', '@pop'],
            [
                /[{]/,
                {
                    token: 'string.escape.curly',
                    switchTo: '@interpolated_compound'
                }
            ],
            ['', '', '@pop'] // just a # is interpreted as a #
        ],
        // any code
        interpolated_compound: [
            [/[}]/, { token: 'string.escape.curly', next: '@pop' }],
            { include: '@root' }
        ],
        // %r quoted regexp
        // pregexp.<open>.<close> where open/close are the open/close delimiter
        pregexp: [
            { include: '@whitespace' },
            // turns out that you can quote using regex control characters, aargh!
            // for example; %r|kgjgaj| is ok (even though | is used for alternation)
            // so, we need to match those first
            [
                /[^\(\{\[\\]/,
                {
                    cases: {
                        '$#==$S3': { token: 'regexp.delim', next: '@pop' },
                        '$#==$S2': { token: 'regexp.delim', next: '@push' },
                        '~[)}\\]]': '@brackets.regexp.escape.control',
                        '~@regexpctl': 'regexp.escape.control',
                        '@default': 'regexp'
                    }
                }
            ],
            { include: '@regexcontrol' }
        ],
        // We match regular expression quite precisely
        regexp: [
            { include: '@regexcontrol' },
            [/[^\\\/]/, 'regexp'],
            ['/[ixmp]*', { token: 'regexp.delim' }, '@pop']
        ],
        regexcontrol: [
            [
                /(\{)(\d+(?:,\d*)?)(\})/,
                [
                    '@brackets.regexp.escape.control',
                    'regexp.escape.control',
                    '@brackets.regexp.escape.control'
                ]
            ],
            [
                /(\[)(\^?)/,
                [
                    '@brackets.regexp.escape.control',
                    { token: 'regexp.escape.control', next: '@regexrange' }
                ]
            ],
            [/(\()(\?[:=!])/, ['@brackets.regexp.escape.control', 'regexp.escape.control']],
            [/\(\?#/, { token: 'regexp.escape.control', next: '@regexpcomment' }],
            [/[()]/, '@brackets.regexp.escape.control'],
            [/@regexpctl/, 'regexp.escape.control'],
            [/\\$/, 'regexp.escape'],
            [/@regexpesc/, 'regexp.escape'],
            [/\\\./, 'regexp.invalid'],
            [/#/, 'regexp.escape', '@interpolated']
        ],
        regexrange: [
            [/-/, 'regexp.escape.control'],
            [/\^/, 'regexp.invalid'],
            [/\\$/, 'regexp.escape'],
            [/@regexpesc/, 'regexp.escape'],
            [/[^\]]/, 'regexp'],
            [/\]/, '@brackets.regexp.escape.control', '@pop']
        ],
        regexpcomment: [
            [/[^)]+/, 'comment'],
            [/\)/, { token: 'regexp.escape.control', next: '@pop' }]
        ],
        // % quoted strings
        // A bit repetitive since we need to often special case the kind of ending delimiter
        pstring: [
            [/%([qws])\(/, { token: 'string.$1.delim', switchTo: '@qstring.$1.(.)' }],
            [/%([qws])\[/, { token: 'string.$1.delim', switchTo: '@qstring.$1.[.]' }],
            [/%([qws])\{/, { token: 'string.$1.delim', switchTo: '@qstring.$1.{.}' }],
            [/%([qws])</, { token: 'string.$1.delim', switchTo: '@qstring.$1.<.>' }],
            [/%([qws])(@delim)/, { token: 'string.$1.delim', switchTo: '@qstring.$1.$2.$2' }],
            [/%r\(/, { token: 'regexp.delim', switchTo: '@pregexp.(.)' }],
            [/%r\[/, { token: 'regexp.delim', switchTo: '@pregexp.[.]' }],
            [/%r\{/, { token: 'regexp.delim', switchTo: '@pregexp.{.}' }],
            [/%r</, { token: 'regexp.delim', switchTo: '@pregexp.<.>' }],
            [/%r(@delim)/, { token: 'regexp.delim', switchTo: '@pregexp.$1.$1' }],
            [/%(x|W|Q?)\(/, { token: 'string.$1.delim', switchTo: '@qqstring.$1.(.)' }],
            [/%(x|W|Q?)\[/, { token: 'string.$1.delim', switchTo: '@qqstring.$1.[.]' }],
            [/%(x|W|Q?)\{/, { token: 'string.$1.delim', switchTo: '@qqstring.$1.{.}' }],
            [/%(x|W|Q?)</, { token: 'string.$1.delim', switchTo: '@qqstring.$1.<.>' }],
            [/%(x|W|Q?)(@delim)/, { token: 'string.$1.delim', switchTo: '@qqstring.$1.$2.$2' }],
            [/%([rqwsxW]|Q?)./, { token: 'invalid', next: '@pop' }],
            [/./, { token: 'invalid', next: '@pop' }] // recover
        ],
        // non-expanded quoted string.
        // qstring.<kind>.<open>.<close>
        //  kind = q|w|s  (single quote, array, symbol)
        //  open = open delimiter
        //  close = close delimiter
        qstring: [
            [/\\$/, 'string.$S2.escape'],
            [/\\./, 'string.$S2.escape'],
            [
                /./,
                {
                    cases: {
                        '$#==$S4': { token: 'string.$S2.delim', next: '@pop' },
                        '$#==$S3': { token: 'string.$S2.delim', next: '@push' },
                        '@default': 'string.$S2'
                    }
                }
            ]
        ],
        // expanded quoted string.
        // qqstring.<kind>.<open>.<close>
        //  kind = Q|W|x  (double quote, array, command)
        //  open = open delimiter
        //  close = close delimiter
        qqstring: [[/#/, 'string.$S2.escape', '@interpolated'], { include: '@qstring' }],
        // whitespace & comments
        whitespace: [
            [/[ \t\r\n]+/, ''],
            [/^\s*=begin\b/, 'comment', '@comment'],
            [/#.*$/, 'comment']
        ],
        comment: [
            [/[^=]+/, 'comment'],
            [/^\s*=begin\b/, 'comment.invalid'],
            [/^\s*=end\b.*/, 'comment', '@pop'],
            [/[=]/, 'comment']
        ]
    }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcm9zcy1jb2RlLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2ljLWxhbmd1YWdlcy9ydWJ5L3J1YnkuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFTLFlBQVksR0FBRztBQUNqQyxTQUFTLHdCQUF3QjtBQUNqQyxTQUFTLHdCQUF3QjtBQUNqQyxTQUFTLHdCQUF3QjtBQUNqQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVMsU0FBUyxZQUFZLEdBQUc7QUFDakMsU0FBUyx3QkFBd0I7QUFDakMsU0FBUyx3QkFBd0I7QUFDakMsU0FBUyx3QkFBd0I7QUFDakMsU0FBUztBQUNUO0FBQ0E7QUFDQSwwTkFBME47QUFDMU4sbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LGtCQUFrQixJQUFJLDZDQUE2QyxFQUFFLEdBQUc7QUFDeEUscUJBQXFCLGtEQUFrRDtBQUN2RSw0QkFBNEIsb0RBQW9EO0FBQ2hGLDZCQUE2Qix5REFBeUQ7QUFDdEYsNkJBQTZCLHlEQUF5RDtBQUN0Rix5QkFBeUIsSUFBSSxvREFBb0QsRUFBRSxHQUFHO0FBQ3RGLDRCQUE0Qix5REFBeUQ7QUFDckYsbUNBQW1DLDJEQUEyRDtBQUM5RixpQ0FBaUMsaUNBQWlDO0FBQ2xFLG1CQUFtQixpQ0FBaUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsMENBQTBDO0FBQzlFLG9DQUFvQywyQ0FBMkM7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsc0JBQXNCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvcl9lc21fdnNfYmFzaWMtbGFuZ3VhZ2VzX3J1YnlfcnVieV9qcy5idW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuZXhwb3J0IHZhciBjb25mID0ge1xyXG4gICAgY29tbWVudHM6IHtcclxuICAgICAgICBsaW5lQ29tbWVudDogJyMnLFxyXG4gICAgICAgIGJsb2NrQ29tbWVudDogWyc9YmVnaW4nLCAnPWVuZCddXHJcbiAgICB9LFxyXG4gICAgYnJhY2tldHM6IFtcclxuICAgICAgICBbJygnLCAnKSddLFxyXG4gICAgICAgIFsneycsICd9J10sXHJcbiAgICAgICAgWydbJywgJ10nXVxyXG4gICAgXSxcclxuICAgIGF1dG9DbG9zaW5nUGFpcnM6IFtcclxuICAgICAgICB7IG9wZW46ICd7JywgY2xvc2U6ICd9JyB9LFxyXG4gICAgICAgIHsgb3BlbjogJ1snLCBjbG9zZTogJ10nIH0sXHJcbiAgICAgICAgeyBvcGVuOiAnKCcsIGNsb3NlOiAnKScgfSxcclxuICAgICAgICB7IG9wZW46ICdcIicsIGNsb3NlOiAnXCInIH0sXHJcbiAgICAgICAgeyBvcGVuOiBcIidcIiwgY2xvc2U6IFwiJ1wiIH1cclxuICAgIF0sXHJcbiAgICBzdXJyb3VuZGluZ1BhaXJzOiBbXHJcbiAgICAgICAgeyBvcGVuOiAneycsIGNsb3NlOiAnfScgfSxcclxuICAgICAgICB7IG9wZW46ICdbJywgY2xvc2U6ICddJyB9LFxyXG4gICAgICAgIHsgb3BlbjogJygnLCBjbG9zZTogJyknIH0sXHJcbiAgICAgICAgeyBvcGVuOiAnXCInLCBjbG9zZTogJ1wiJyB9LFxyXG4gICAgICAgIHsgb3BlbjogXCInXCIsIGNsb3NlOiBcIidcIiB9XHJcbiAgICBdLFxyXG4gICAgaW5kZW50YXRpb25SdWxlczoge1xyXG4gICAgICAgIGluY3JlYXNlSW5kZW50UGF0dGVybjogbmV3IFJlZ0V4cCgnXlxcXFxzKigoYmVnaW58Y2xhc3N8KHByaXZhdGV8cHJvdGVjdGVkKVxcXFxzK2RlZnxkZWZ8ZWxzZXxlbHNpZnxlbnN1cmV8Zm9yfGlmfG1vZHVsZXxyZXNjdWV8dW5sZXNzfHVudGlsfHdoZW58d2hpbGV8Y2FzZSl8KFteI10qXFxcXHNkb1xcXFxiKXwoW14jXSo9XFxcXHMqKGNhc2V8aWZ8dW5sZXNzKSkpXFxcXGIoW14jXFxcXHs7XXwoXCJ8XFwnfC8pLipcXFxcNCkqKCMuKik/JCcpLFxyXG4gICAgICAgIGRlY3JlYXNlSW5kZW50UGF0dGVybjogbmV3IFJlZ0V4cCgnXlxcXFxzKihbfVxcXFxdXShbLCldP1xcXFxzKigjfCQpfFxcXFwuW2EtekEtWl9dXFxcXHcqXFxcXGIpfChlbmR8cmVzY3VlfGVuc3VyZXxlbHNlfGVsc2lmfHdoZW4pXFxcXGIpJylcclxuICAgIH1cclxufTtcclxuLypcclxuICogUnVieSBsYW5ndWFnZSBkZWZpbml0aW9uXHJcbiAqXHJcbiAqIFF1aXRlIGEgY29tcGxleCBsYW5ndWFnZSBkdWUgdG8gZWxhYm9yYXRlIGVzY2FwZSBzZXF1ZW5jZXNcclxuICogYW5kIHF1b3Rpbmcgb2YgbGl0ZXJhdGUgc3RyaW5ncy9yZWd1bGFyIGV4cHJlc3Npb25zLCBhbmRcclxuICogYW4gJ2VuZCcga2V5d29yZCB0aGF0IGRvZXMgbm90IGFsd2F5cyBhcHBseSB0byBtb2RpZmllcnMgbGlrZSB1bnRpbCBhbmQgd2hpbGUsXHJcbiAqIGFuZCBhICdkbycga2V5d29yZCB0aGF0IHNvbWV0aW1lcyBzdGFydHMgYSBibG9jaywgYnV0IHNvbWV0aW1lcyBpcyBwYXJ0IG9mXHJcbiAqIGFub3RoZXIgc3RhdGVtZW50IChsaWtlICd3aGlsZScpLlxyXG4gKlxyXG4gKiAoMSkgZW5kIGJsb2NrczpcclxuICogJ2VuZCcgbWF5IGVuZCBkZWNsYXJhdGlvbnMgbGlrZSBpZiBvciB1bnRpbCwgYnV0IHNvbWV0aW1lcyAnaWYnIG9yICd1bnRpbCdcclxuICogYXJlIG1vZGlmaWVycyB3aGVyZSB0aGVyZSBpcyBubyAnZW5kJy4gQWxzbywgJ2RvJyBzb21ldGltZXMgc3RhcnRzIGEgYmxvY2tcclxuICogdGhhdCBpcyBlbmRlZCBieSAnZW5kJywgYnV0IHNvbWV0aW1lcyBpdCBpcyBwYXJ0IG9mIGEgJ3doaWxlJywgJ2ZvcicsIG9yICd1bnRpbCdcclxuICogVG8gZG8gcHJvcGVyIGJyYWNlIG1hdGNoaW5nIHdlIGRvIHNvbWUgZWxhYm9yYXRlIHN0YXRlIG1hbmlwdWxhdGlvbi5cclxuICogc29tZSBleGFtcGxlczpcclxuICpcclxuICogICB1bnRpbCBibGEgZG9cclxuICogICAgIHdvcmsgdW50aWwgdGlyZWRcclxuICogICAgIGxpc3QuZWFjaCBkb1xyXG4gKiAgICAgICBzb21ldGhpbmcgaWYgdGVzdFxyXG4gKiAgICAgZW5kXHJcbiAqICAgZW5kXHJcbiAqXHJcbiAqIG9yXHJcbiAqXHJcbiAqIGlmIHRlc3RcclxuICogIHNvbWV0aGluZyAoaWYgdGVzdCB0aGVuIHggZW5kKVxyXG4gKiAgYmFyIGlmIGJsYVxyXG4gKiBlbmRcclxuICpcclxuICogb3IsIGhvdyBhYm91dCB1c2luZyBjbGFzcyBhcyBhIHByb3BlcnR5Li5cclxuICpcclxuICogY2xhc3MgVGVzdFxyXG4gKiAgIGRlZiBlbmRwb2ludFxyXG4gKiAgICAgc2VsZi5jbGFzcy5lbmRwb2ludCB8fCByb3V0ZXNcclxuICogICBlbmRcclxuICogZW5kXHJcbiAqXHJcbiAqICgyKSBxdW90aW5nOlxyXG4gKiB0aGVyZSBhcmUgbWFueSBraW5kcyBvZiBzdHJpbmdzIGFuZCBlc2NhcGUgc2VxdWVuY2VzLiBCdXQgYWxzbywgb25lIGNhblxyXG4gKiBzdGFydCBtYW55IHN0cmluZy1saWtlIHRoaW5ncyBhcyAnJXF4JyB3aGVyZSBxIHNwZWNpZmllcyB0aGUga2luZCBvZiBzdHJpbmdcclxuICogKGxpa2UgYSBjb21tYW5kLCBlc2NhcGUgZXhwYW5kZWQsIHJlZ3VsYXIgZXhwcmVzc2lvbiwgc3ltYm9sIGV0Yy4pLCBhbmQgeCBpc1xyXG4gKiBzb21lIGNoYXJhY3RlciBhbmQgb25seSBhbm90aGVyICd4JyBlbmRzIHRoZSBzZXF1ZW5jZS4gRXhjZXB0IGZvciBicmFja2V0c1xyXG4gKiB3aGVyZSB0aGUgY2xvc2luZyBicmFja2V0IGVuZHMgdGhlIHNlcXVlbmNlLi4gYW5kIGV4Y2VwdCBmb3IgYSBuZXN0ZWQgYnJhY2tldFxyXG4gKiBpbnNpZGUgdGhlIHN0cmluZyBsaWtlIGVudGl0eS4gQWxzbywgc3VjaCBzdHJpbmdzIGNhbiBjb250YWluIGludGVycG9sYXRlZFxyXG4gKiBydWJ5IGV4cHJlc3Npb25zIGFnYWluIChhbmQgc3BhbiBtdWx0aXBsZSBsaW5lcykuIE1vcmVvdmVyLCBleHBhbmRlZFxyXG4gKiByZWd1bGFyIGV4cHJlc3Npb24gY2FuIGFsc28gY29udGFpbiBjb21tZW50cy5cclxuICovXHJcbmV4cG9ydCB2YXIgbGFuZ3VhZ2UgPSB7XHJcbiAgICB0b2tlblBvc3RmaXg6ICcucnVieScsXHJcbiAgICBrZXl3b3JkczogW1xyXG4gICAgICAgICdfX0xJTkVfXycsXHJcbiAgICAgICAgJ19fRU5DT0RJTkdfXycsXHJcbiAgICAgICAgJ19fRklMRV9fJyxcclxuICAgICAgICAnQkVHSU4nLFxyXG4gICAgICAgICdFTkQnLFxyXG4gICAgICAgICdhbGlhcycsXHJcbiAgICAgICAgJ2FuZCcsXHJcbiAgICAgICAgJ2JlZ2luJyxcclxuICAgICAgICAnYnJlYWsnLFxyXG4gICAgICAgICdjYXNlJyxcclxuICAgICAgICAnY2xhc3MnLFxyXG4gICAgICAgICdkZWYnLFxyXG4gICAgICAgICdkZWZpbmVkPycsXHJcbiAgICAgICAgJ2RvJyxcclxuICAgICAgICAnZWxzZScsXHJcbiAgICAgICAgJ2Vsc2lmJyxcclxuICAgICAgICAnZW5kJyxcclxuICAgICAgICAnZW5zdXJlJyxcclxuICAgICAgICAnZm9yJyxcclxuICAgICAgICAnZmFsc2UnLFxyXG4gICAgICAgICdpZicsXHJcbiAgICAgICAgJ2luJyxcclxuICAgICAgICAnbW9kdWxlJyxcclxuICAgICAgICAnbmV4dCcsXHJcbiAgICAgICAgJ25pbCcsXHJcbiAgICAgICAgJ25vdCcsXHJcbiAgICAgICAgJ29yJyxcclxuICAgICAgICAncmVkbycsXHJcbiAgICAgICAgJ3Jlc2N1ZScsXHJcbiAgICAgICAgJ3JldHJ5JyxcclxuICAgICAgICAncmV0dXJuJyxcclxuICAgICAgICAnc2VsZicsXHJcbiAgICAgICAgJ3N1cGVyJyxcclxuICAgICAgICAndGhlbicsXHJcbiAgICAgICAgJ3RydWUnLFxyXG4gICAgICAgICd1bmRlZicsXHJcbiAgICAgICAgJ3VubGVzcycsXHJcbiAgICAgICAgJ3VudGlsJyxcclxuICAgICAgICAnd2hlbicsXHJcbiAgICAgICAgJ3doaWxlJyxcclxuICAgICAgICAneWllbGQnXHJcbiAgICBdLFxyXG4gICAga2V5d29yZG9wczogWyc6OicsICcuLicsICcuLi4nLCAnPycsICc6JywgJz0+J10sXHJcbiAgICBidWlsdGluczogW1xyXG4gICAgICAgICdyZXF1aXJlJyxcclxuICAgICAgICAncHVibGljJyxcclxuICAgICAgICAncHJpdmF0ZScsXHJcbiAgICAgICAgJ2luY2x1ZGUnLFxyXG4gICAgICAgICdleHRlbmQnLFxyXG4gICAgICAgICdhdHRyX3JlYWRlcicsXHJcbiAgICAgICAgJ3Byb3RlY3RlZCcsXHJcbiAgICAgICAgJ3ByaXZhdGVfY2xhc3NfbWV0aG9kJyxcclxuICAgICAgICAncHJvdGVjdGVkX2NsYXNzX21ldGhvZCcsXHJcbiAgICAgICAgJ25ldydcclxuICAgIF0sXHJcbiAgICAvLyB0aGVzZSBhcmUgY2xvc2VkIGJ5ICdlbmQnIChpZiwgd2hpbGUgYW5kIHVudGlsIGFyZSBoYW5kbGVkIHNlcGFyYXRlbHkpXHJcbiAgICBkZWNsYXJhdGlvbnM6IFtcclxuICAgICAgICAnbW9kdWxlJyxcclxuICAgICAgICAnY2xhc3MnLFxyXG4gICAgICAgICdkZWYnLFxyXG4gICAgICAgICdjYXNlJyxcclxuICAgICAgICAnZG8nLFxyXG4gICAgICAgICdiZWdpbicsXHJcbiAgICAgICAgJ2ZvcicsXHJcbiAgICAgICAgJ2lmJyxcclxuICAgICAgICAnd2hpbGUnLFxyXG4gICAgICAgICd1bnRpbCcsXHJcbiAgICAgICAgJ3VubGVzcydcclxuICAgIF0sXHJcbiAgICBsaW5lZGVjbHM6IFsnZGVmJywgJ2Nhc2UnLCAnZG8nLCAnYmVnaW4nLCAnZm9yJywgJ2lmJywgJ3doaWxlJywgJ3VudGlsJywgJ3VubGVzcyddLFxyXG4gICAgb3BlcmF0b3JzOiBbXHJcbiAgICAgICAgJ14nLFxyXG4gICAgICAgICcmJyxcclxuICAgICAgICAnfCcsXHJcbiAgICAgICAgJzw9PicsXHJcbiAgICAgICAgJz09JyxcclxuICAgICAgICAnPT09JyxcclxuICAgICAgICAnIX4nLFxyXG4gICAgICAgICc9ficsXHJcbiAgICAgICAgJz4nLFxyXG4gICAgICAgICc+PScsXHJcbiAgICAgICAgJzwnLFxyXG4gICAgICAgICc8PScsXHJcbiAgICAgICAgJzw8JyxcclxuICAgICAgICAnPj4nLFxyXG4gICAgICAgICcrJyxcclxuICAgICAgICAnLScsXHJcbiAgICAgICAgJyonLFxyXG4gICAgICAgICcvJyxcclxuICAgICAgICAnJScsXHJcbiAgICAgICAgJyoqJyxcclxuICAgICAgICAnficsXHJcbiAgICAgICAgJytAJyxcclxuICAgICAgICAnLUAnLFxyXG4gICAgICAgICdbXScsXHJcbiAgICAgICAgJ1tdPScsXHJcbiAgICAgICAgJ2AnLFxyXG4gICAgICAgICcrPScsXHJcbiAgICAgICAgJy09JyxcclxuICAgICAgICAnKj0nLFxyXG4gICAgICAgICcqKj0nLFxyXG4gICAgICAgICcvPScsXHJcbiAgICAgICAgJ149JyxcclxuICAgICAgICAnJT0nLFxyXG4gICAgICAgICc8PD0nLFxyXG4gICAgICAgICc+Pj0nLFxyXG4gICAgICAgICcmPScsXHJcbiAgICAgICAgJyYmPScsXHJcbiAgICAgICAgJ3x8PScsXHJcbiAgICAgICAgJ3w9J1xyXG4gICAgXSxcclxuICAgIGJyYWNrZXRzOiBbXHJcbiAgICAgICAgeyBvcGVuOiAnKCcsIGNsb3NlOiAnKScsIHRva2VuOiAnZGVsaW1pdGVyLnBhcmVudGhlc2lzJyB9LFxyXG4gICAgICAgIHsgb3BlbjogJ3snLCBjbG9zZTogJ30nLCB0b2tlbjogJ2RlbGltaXRlci5jdXJseScgfSxcclxuICAgICAgICB7IG9wZW46ICdbJywgY2xvc2U6ICddJywgdG9rZW46ICdkZWxpbWl0ZXIuc3F1YXJlJyB9XHJcbiAgICBdLFxyXG4gICAgLy8gd2UgaW5jbHVkZSB0aGVzZSBjb21tb24gcmVndWxhciBleHByZXNzaW9uc1xyXG4gICAgc3ltYm9sczogL1s9Pjwhfj86JnwrXFwtKlxcL1xcXiVcXC5dKy8sXHJcbiAgICAvLyBlc2NhcGUgc2VxdWVuY2VzXHJcbiAgICBlc2NhcGU6IC8oPzpbYWJlZm5yc3R2XFxcXFwiJ1xcblxccl18WzAtN117MSwzfXx4WzAtOUEtRmEtZl17MSwyfXx1WzAtOUEtRmEtZl17NH0pLyxcclxuICAgIGVzY2FwZXM6IC9cXFxcKD86Q1xcLShAZXNjYXBlfC4pfGMoQGVzY2FwZXwuKXxAZXNjYXBlKS8sXHJcbiAgICBkZWNwYXJ0OiAvXFxkKF8/XFxkKSovLFxyXG4gICAgZGVjaW1hbDogLzB8QGRlY3BhcnQvLFxyXG4gICAgZGVsaW06IC9bXmEtekEtWjAtOVxcc1xcblxccl0vLFxyXG4gICAgaGVyZWRlbGltOiAvKD86XFx3K3wnW14nXSonfFwiW15cIl0qXCJ8YFteYF0qYCkvLFxyXG4gICAgcmVnZXhwY3RsOiAvWygpe31cXFtcXF1cXCRcXF58XFwtKis/XFwuXS8sXHJcbiAgICByZWdleHBlc2M6IC9cXFxcKD86W0F6WmJCZERmbnJzdHZ3V24wXFxcXFxcL118QHJlZ2V4cGN0bHxjW0EtWl18eFswLTlhLWZBLUZdezJ9fHVbMC05YS1mQS1GXXs0fSk/LyxcclxuICAgIC8vIFRoZSBtYWluIHRva2VuaXplciBmb3Igb3VyIGxhbmd1YWdlc1xyXG4gICAgdG9rZW5pemVyOiB7XHJcbiAgICAgICAgLy8gTWFpbiBlbnRyeS5cclxuICAgICAgICAvLyByb290LjxkZWNsPiB3aGVyZSBkZWNsIGlzIHRoZSBjdXJyZW50IG9wZW5pbmcgZGVjbGFyYXRpb24gKGxpa2UgJ2NsYXNzJylcclxuICAgICAgICByb290OiBbXHJcbiAgICAgICAgICAgIC8vIGlkZW50aWZpZXJzIGFuZCBrZXl3b3Jkc1xyXG4gICAgICAgICAgICAvLyBtb3N0IGNvbXBsZXhpdHkgaGVyZSBpcyBkdWUgdG8gbWF0Y2hpbmcgJ2VuZCcgY29ycmVjdGx5IHdpdGggZGVjbGFyYXRpb25zLlxyXG4gICAgICAgICAgICAvLyBXZSBkaXN0aW5ndWlzaCBhIGRlY2xhcmF0aW9uIHRoYXQgY29tZXMgZmlyc3Qgb24gYSBsaW5lLCB2ZXJzdXMgZGVjbGFyYXRpb25zIGZ1cnRoZXIgb24gYSBsaW5lICh3aGljaCBhcmUgbW9zdCBsaWtleSBtb2RpZmllcnMpXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIC9eKFxccyopKFthLXpfXVxcdypbIT89XT8pLyxcclxuICAgICAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICAgICAnd2hpdGUnLFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZXM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmb3J8dW50aWx8d2hpbGUnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW46ICdrZXl3b3JkLiQyJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0OiAnQGRvZGVjbC4kMidcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQGRlY2xhcmF0aW9ucyc6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogJ2tleXdvcmQuJDInLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQ6ICdAcm9vdC4kMidcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHsgdG9rZW46ICdrZXl3b3JkLiRTMicsIG5leHQ6ICdAcG9wJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0BrZXl3b3Jkcyc6ICdrZXl3b3JkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdAYnVpbHRpbnMnOiAncHJlZGVmaW5lZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQGRlZmF1bHQnOiAnaWRlbnRpZmllcidcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgL1thLXpfXVxcdypbIT89XT8vLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2VzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdpZnx1bmxlc3N8d2hpbGV8dW50aWwnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogJ2tleXdvcmQuJDB4JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQ6ICdAbW9kaWZpZXIuJDB4J1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3I6IHsgdG9rZW46ICdrZXl3b3JkLiQyJywgbmV4dDogJ0Bkb2RlY2wuJDInIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdAbGluZWRlY2xzJzogeyB0b2tlbjogJ2tleXdvcmQuJDAnLCBuZXh0OiAnQHJvb3QuJDAnIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogeyB0b2tlbjogJ2tleXdvcmQuJFMyJywgbmV4dDogJ0Bwb3AnIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdAa2V5d29yZHMnOiAna2V5d29yZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdAYnVpbHRpbnMnOiAncHJlZGVmaW5lZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdAZGVmYXVsdCc6ICdpZGVudGlmaWVyJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgWy9bQS1aXVtcXHddKlshPz1dPy8sICdjb25zdHJ1Y3Rvci5pZGVudGlmaWVyJ10sXHJcbiAgICAgICAgICAgIFsvXFwkW1xcd10qLywgJ2dsb2JhbC5jb25zdGFudCddLFxyXG4gICAgICAgICAgICBbL0BbXFx3XSovLCAnbmFtZXNwYWNlLmluc3RhbmNlLmlkZW50aWZpZXInXSxcclxuICAgICAgICAgICAgWy9AQEBbXFx3XSovLCAnbmFtZXNwYWNlLmNsYXNzLmlkZW50aWZpZXInXSxcclxuICAgICAgICAgICAgLy8gaGVyZSBkb2N1bWVudFxyXG4gICAgICAgICAgICBbLzw8Wy1+XShAaGVyZWRlbGltKS4qLywgeyB0b2tlbjogJ3N0cmluZy5oZXJlZG9jLmRlbGltaXRlcicsIG5leHQ6ICdAaGVyZWRvYy4kMScgfV0sXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIC9bIFxcdFxcclxcbl0rPDwoQGhlcmVkZWxpbSkuKi8sXHJcbiAgICAgICAgICAgICAgICB7IHRva2VuOiAnc3RyaW5nLmhlcmVkb2MuZGVsaW1pdGVyJywgbmV4dDogJ0BoZXJlZG9jLiQxJyB9XHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIFsvXjw8KEBoZXJlZGVsaW0pLiovLCB7IHRva2VuOiAnc3RyaW5nLmhlcmVkb2MuZGVsaW1pdGVyJywgbmV4dDogJ0BoZXJlZG9jLiQxJyB9XSxcclxuICAgICAgICAgICAgLy8gd2hpdGVzcGFjZVxyXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAd2hpdGVzcGFjZScgfSxcclxuICAgICAgICAgICAgLy8gc3RyaW5nc1xyXG4gICAgICAgICAgICBbL1wiLywgeyB0b2tlbjogJ3N0cmluZy5kLmRlbGltJywgbmV4dDogJ0Bkc3RyaW5nLmQuXCInIH1dLFxyXG4gICAgICAgICAgICBbLycvLCB7IHRva2VuOiAnc3RyaW5nLnNxLmRlbGltJywgbmV4dDogJ0Bzc3RyaW5nLnNxJyB9XSxcclxuICAgICAgICAgICAgLy8gJSBsaXRlcmFscy4gRm9yIGVmZmljaWVuY3ksIHJlbWF0Y2ggaW4gdGhlICdwc3RyaW5nJyBzdGF0ZVxyXG4gICAgICAgICAgICBbLyUoW3JzcXh3V118UT8pLywgeyB0b2tlbjogJ0ByZW1hdGNoJywgbmV4dDogJ3BzdHJpbmcnIH1dLFxyXG4gICAgICAgICAgICAvLyBjb21tYW5kcyBhbmQgc3ltYm9sc1xyXG4gICAgICAgICAgICBbL2AvLCB7IHRva2VuOiAnc3RyaW5nLnguZGVsaW0nLCBuZXh0OiAnQGRzdHJpbmcueC5gJyB9XSxcclxuICAgICAgICAgICAgWy86KFxcd3xbJEBdKVxcdypbIT89XT8vLCAnc3RyaW5nLnMnXSxcclxuICAgICAgICAgICAgWy86XCIvLCB7IHRva2VuOiAnc3RyaW5nLnMuZGVsaW0nLCBuZXh0OiAnQGRzdHJpbmcucy5cIicgfV0sXHJcbiAgICAgICAgICAgIFsvOicvLCB7IHRva2VuOiAnc3RyaW5nLnMuZGVsaW0nLCBuZXh0OiAnQHNzdHJpbmcucycgfV0sXHJcbiAgICAgICAgICAgIC8vIHJlZ3VsYXIgZXhwcmVzc2lvbnMuIExvb2thaGVhZCBmb3IgYSAobm90IGVzY2FwZWQpIGNsb3NpbmcgZm9yd2FyZHNsYXNoIG9uIHRoZSBzYW1lIGxpbmVcclxuICAgICAgICAgICAgWy9cXC8oPz0oXFxcXFxcL3xbXlxcL1xcbl0pK1xcLykvLCB7IHRva2VuOiAncmVnZXhwLmRlbGltJywgbmV4dDogJ0ByZWdleHAnIH1dLFxyXG4gICAgICAgICAgICAvLyBkZWxpbWl0ZXJzIGFuZCBvcGVyYXRvcnNcclxuICAgICAgICAgICAgWy9be30oKVxcW1xcXV0vLCAnQGJyYWNrZXRzJ10sXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIC9Ac3ltYm9scy8sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZXM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0BrZXl3b3Jkb3BzJzogJ2tleXdvcmQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQG9wZXJhdG9ycyc6ICdvcGVyYXRvcicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdAZGVmYXVsdCc6ICcnXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbL1s7LF0vLCAnZGVsaW1pdGVyJ10sXHJcbiAgICAgICAgICAgIC8vIG51bWJlcnNcclxuICAgICAgICAgICAgWy8wW3hYXVswLTlhLWZBLUZdKF8/WzAtOWEtZkEtRl0pKi8sICdudW1iZXIuaGV4J10sXHJcbiAgICAgICAgICAgIFsvMFtfb09dWzAtN10oXz9bMC03XSkqLywgJ251bWJlci5vY3RhbCddLFxyXG4gICAgICAgICAgICBbLzBbYkJdWzAxXShfP1swMV0pKi8sICdudW1iZXIuYmluYXJ5J10sXHJcbiAgICAgICAgICAgIFsvMFtkRF1AZGVjcGFydC8sICdudW1iZXInXSxcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgL0BkZWNpbWFsKChcXC5AZGVjcGFydCk/KFtlRV1bXFwtK10/QGRlY3BhcnQpPykvLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2VzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICQxOiAnbnVtYmVyLmZsb2F0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0BkZWZhdWx0JzogJ251bWJlcidcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICBdLFxyXG4gICAgICAgIC8vIHVzZWQgdG8gbm90IHRyZWF0IGEgJ2RvJyBhcyBhIGJsb2NrIG9wZW5lciBpZiBpdCBvY2N1cnMgb24gdGhlIHNhbWVcclxuICAgICAgICAvLyBsaW5lIGFzIGEgJ2RvJyBzdGF0ZW1lbnQ6ICd3aGlsZXx1bnRpbHxmb3InXHJcbiAgICAgICAgLy8gZG9kZWNsLjxkZWNsPiB3aGVyZSBkZWNsIGlzIHRoZSBkZWNsYXJhdGlvbnMgc3RhcnRlZCwgbGlrZSAnd2hpbGUnXHJcbiAgICAgICAgZG9kZWNsOiBbXHJcbiAgICAgICAgICAgIFsvXi8sIHsgdG9rZW46ICcnLCBzd2l0Y2hUbzogJ0Byb290LiRTMicgfV0sXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIC9bYS16X11cXHcqWyE/PV0/LyxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHsgdG9rZW46ICdrZXl3b3JkLiRTMicsIG5leHQ6ICdAcG9wJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkbzogeyB0b2tlbjogJ2tleXdvcmQnLCBzd2l0Y2hUbzogJ0Byb290LiRTMicgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0BsaW5lZGVjbHMnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogJ0ByZW1hdGNoJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaFRvOiAnQHJvb3QuJFMyJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQGtleXdvcmRzJzogJ2tleXdvcmQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQGJ1aWx0aW5zJzogJ3ByZWRlZmluZWQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQGRlZmF1bHQnOiAnaWRlbnRpZmllcidcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0Byb290JyB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICAvLyB1c2VkIHRvIHByZXZlbnQgcG90ZW50aWFsIG1vZGlmaWVycyAoJ2lmfHVudGlsfHdoaWxlfHVubGVzcycpIHRvIG1hdGNoXHJcbiAgICAgICAgLy8gd2l0aCAnZW5kJyBrZXl3b3Jkcy5cclxuICAgICAgICAvLyBtb2RpZmllci48ZGVjbD54IHdoZXJlIGRlY2wgaXMgdGhlIGRlY2xhcmF0aW9uIHN0YXJ0ZXIsIGxpa2UgJ2lmJ1xyXG4gICAgICAgIG1vZGlmaWVyOiBbXHJcbiAgICAgICAgICAgIFsvXi8sICcnLCAnQHBvcCddLFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAvW2Etel9dXFx3KlshPz1dPy8sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZXM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiB7IHRva2VuOiAna2V5d29yZC4kUzInLCBuZXh0OiAnQHBvcCcgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RoZW58ZWxzZXxlbHNpZnxkbyc6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiAna2V5d29yZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2hUbzogJ0Byb290LiRTMidcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0BsaW5lZGVjbHMnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogJ0ByZW1hdGNoJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaFRvOiAnQHJvb3QuJFMyJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQGtleXdvcmRzJzogJ2tleXdvcmQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQGJ1aWx0aW5zJzogJ3ByZWRlZmluZWQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQGRlZmF1bHQnOiAnaWRlbnRpZmllcidcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0Byb290JyB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICAvLyBzaW5nbGUgcXVvdGUgc3RyaW5ncyAoYWxzbyB1c2VkIGZvciBzeW1ib2xzKVxyXG4gICAgICAgIC8vIHNzdHJpbmcuPGtpbmQ+ICB3aGVyZSBraW5kIGlzICdzcScgKHNpbmdsZSBxdW90ZSkgb3IgJ3MnIChzeW1ib2wpXHJcbiAgICAgICAgc3N0cmluZzogW1xyXG4gICAgICAgICAgICBbL1teXFxcXCddKy8sICdzdHJpbmcuJFMyJ10sXHJcbiAgICAgICAgICAgIFsvXFxcXFxcXFx8XFxcXCd8XFxcXCQvLCAnc3RyaW5nLiRTMi5lc2NhcGUnXSxcclxuICAgICAgICAgICAgWy9cXFxcLi8sICdzdHJpbmcuJFMyLmludmFsaWQnXSxcclxuICAgICAgICAgICAgWy8nLywgeyB0b2tlbjogJ3N0cmluZy4kUzIuZGVsaW0nLCBuZXh0OiAnQHBvcCcgfV1cclxuICAgICAgICBdLFxyXG4gICAgICAgIC8vIGRvdWJsZSBxdW90ZWQgXCJzdHJpbmdcIi5cclxuICAgICAgICAvLyBkc3RyaW5nLjxraW5kPi48ZGVsaW0+IHdoZXJlIGtpbmQgaXMgJ2QnIChkb3VibGUgcXVvdGVkKSwgJ3gnIChjb21tYW5kKSwgb3IgJ3MnIChzeW1ib2wpXHJcbiAgICAgICAgLy8gYW5kIGRlbGltIGlzIHRoZSBlbmRpbmcgZGVsaW1pdGVyIChcIiBvciBgKVxyXG4gICAgICAgIGRzdHJpbmc6IFtcclxuICAgICAgICAgICAgWy9bXlxcXFxgXCIjXSsvLCAnc3RyaW5nLiRTMiddLFxyXG4gICAgICAgICAgICBbLyMvLCAnc3RyaW5nLiRTMi5lc2NhcGUnLCAnQGludGVycG9sYXRlZCddLFxyXG4gICAgICAgICAgICBbL1xcXFwkLywgJ3N0cmluZy4kUzIuZXNjYXBlJ10sXHJcbiAgICAgICAgICAgIFsvQGVzY2FwZXMvLCAnc3RyaW5nLiRTMi5lc2NhcGUnXSxcclxuICAgICAgICAgICAgWy9cXFxcLi8sICdzdHJpbmcuJFMyLmVzY2FwZS5pbnZhbGlkJ10sXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIC9bYFwiXS8sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZXM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJyQjPT0kUzMnOiB7IHRva2VuOiAnc3RyaW5nLiRTMi5kZWxpbScsIG5leHQ6ICdAcG9wJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQGRlZmF1bHQnOiAnc3RyaW5nLiRTMidcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICBdLFxyXG4gICAgICAgIC8vIGxpdGVyYWwgZG9jdW1lbnRzXHJcbiAgICAgICAgLy8gaGVyZWRvYy48Y2xvc2U+IHdoZXJlIGNsb3NlIGlzIHRoZSBjbG9zaW5nIGRlbGltaXRlclxyXG4gICAgICAgIGhlcmVkb2M6IFtcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgL14oXFxzKikoQGhlcmVkZWxpbSkkLyxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnJDI9PSRTMic6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzdHJpbmcuaGVyZWRvYycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHRva2VuOiAnc3RyaW5nLmhlcmVkb2MuZGVsaW1pdGVyJywgbmV4dDogJ0Bwb3AnIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0BkZWZhdWx0JzogWydzdHJpbmcuaGVyZWRvYycsICdzdHJpbmcuaGVyZWRvYyddXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbLy4qLywgJ3N0cmluZy5oZXJlZG9jJ11cclxuICAgICAgICBdLFxyXG4gICAgICAgIC8vIGludGVycG9sYXRlZCBzZXF1ZW5jZVxyXG4gICAgICAgIGludGVycG9sYXRlZDogW1xyXG4gICAgICAgICAgICBbL1xcJFxcdyovLCAnZ2xvYmFsLmNvbnN0YW50JywgJ0Bwb3AnXSxcclxuICAgICAgICAgICAgWy9AXFx3Ki8sICduYW1lc3BhY2UuY2xhc3MuaWRlbnRpZmllcicsICdAcG9wJ10sXHJcbiAgICAgICAgICAgIFsvQEBAXFx3Ki8sICduYW1lc3BhY2UuaW5zdGFuY2UuaWRlbnRpZmllcicsICdAcG9wJ10sXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIC9be10vLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiAnc3RyaW5nLmVzY2FwZS5jdXJseScsXHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoVG86ICdAaW50ZXJwb2xhdGVkX2NvbXBvdW5kJ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbJycsICcnLCAnQHBvcCddIC8vIGp1c3QgYSAjIGlzIGludGVycHJldGVkIGFzIGEgI1xyXG4gICAgICAgIF0sXHJcbiAgICAgICAgLy8gYW55IGNvZGVcclxuICAgICAgICBpbnRlcnBvbGF0ZWRfY29tcG91bmQ6IFtcclxuICAgICAgICAgICAgWy9bfV0vLCB7IHRva2VuOiAnc3RyaW5nLmVzY2FwZS5jdXJseScsIG5leHQ6ICdAcG9wJyB9XSxcclxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQHJvb3QnIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIC8vICVyIHF1b3RlZCByZWdleHBcclxuICAgICAgICAvLyBwcmVnZXhwLjxvcGVuPi48Y2xvc2U+IHdoZXJlIG9wZW4vY2xvc2UgYXJlIHRoZSBvcGVuL2Nsb3NlIGRlbGltaXRlclxyXG4gICAgICAgIHByZWdleHA6IFtcclxuICAgICAgICAgICAgeyBpbmNsdWRlOiAnQHdoaXRlc3BhY2UnIH0sXHJcbiAgICAgICAgICAgIC8vIHR1cm5zIG91dCB0aGF0IHlvdSBjYW4gcXVvdGUgdXNpbmcgcmVnZXggY29udHJvbCBjaGFyYWN0ZXJzLCBhYXJnaCFcclxuICAgICAgICAgICAgLy8gZm9yIGV4YW1wbGU7ICVyfGtnamdhanwgaXMgb2sgKGV2ZW4gdGhvdWdoIHwgaXMgdXNlZCBmb3IgYWx0ZXJuYXRpb24pXHJcbiAgICAgICAgICAgIC8vIHNvLCB3ZSBuZWVkIHRvIG1hdGNoIHRob3NlIGZpcnN0XHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIC9bXlxcKFxce1xcW1xcXFxdLyxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnJCM9PSRTMyc6IHsgdG9rZW46ICdyZWdleHAuZGVsaW0nLCBuZXh0OiAnQHBvcCcgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJyQjPT0kUzInOiB7IHRva2VuOiAncmVnZXhwLmRlbGltJywgbmV4dDogJ0BwdXNoJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnflspfVxcXFxdXSc6ICdAYnJhY2tldHMucmVnZXhwLmVzY2FwZS5jb250cm9sJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ35AcmVnZXhwY3RsJzogJ3JlZ2V4cC5lc2NhcGUuY29udHJvbCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdAZGVmYXVsdCc6ICdyZWdleHAnXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICB7IGluY2x1ZGU6ICdAcmVnZXhjb250cm9sJyB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICAvLyBXZSBtYXRjaCByZWd1bGFyIGV4cHJlc3Npb24gcXVpdGUgcHJlY2lzZWx5XHJcbiAgICAgICAgcmVnZXhwOiBbXHJcbiAgICAgICAgICAgIHsgaW5jbHVkZTogJ0ByZWdleGNvbnRyb2wnIH0sXHJcbiAgICAgICAgICAgIFsvW15cXFxcXFwvXS8sICdyZWdleHAnXSxcclxuICAgICAgICAgICAgWycvW2l4bXBdKicsIHsgdG9rZW46ICdyZWdleHAuZGVsaW0nIH0sICdAcG9wJ11cclxuICAgICAgICBdLFxyXG4gICAgICAgIHJlZ2V4Y29udHJvbDogW1xyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAvKFxceykoXFxkKyg/OixcXGQqKT8pKFxcfSkvLFxyXG4gICAgICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgICAgICdAYnJhY2tldHMucmVnZXhwLmVzY2FwZS5jb250cm9sJyxcclxuICAgICAgICAgICAgICAgICAgICAncmVnZXhwLmVzY2FwZS5jb250cm9sJyxcclxuICAgICAgICAgICAgICAgICAgICAnQGJyYWNrZXRzLnJlZ2V4cC5lc2NhcGUuY29udHJvbCdcclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgLyhcXFspKFxcXj8pLyxcclxuICAgICAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICAgICAnQGJyYWNrZXRzLnJlZ2V4cC5lc2NhcGUuY29udHJvbCcsXHJcbiAgICAgICAgICAgICAgICAgICAgeyB0b2tlbjogJ3JlZ2V4cC5lc2NhcGUuY29udHJvbCcsIG5leHQ6ICdAcmVnZXhyYW5nZScgfVxyXG4gICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbLyhcXCgpKFxcP1s6PSFdKS8sIFsnQGJyYWNrZXRzLnJlZ2V4cC5lc2NhcGUuY29udHJvbCcsICdyZWdleHAuZXNjYXBlLmNvbnRyb2wnXV0sXHJcbiAgICAgICAgICAgIFsvXFwoXFw/Iy8sIHsgdG9rZW46ICdyZWdleHAuZXNjYXBlLmNvbnRyb2wnLCBuZXh0OiAnQHJlZ2V4cGNvbW1lbnQnIH1dLFxyXG4gICAgICAgICAgICBbL1soKV0vLCAnQGJyYWNrZXRzLnJlZ2V4cC5lc2NhcGUuY29udHJvbCddLFxyXG4gICAgICAgICAgICBbL0ByZWdleHBjdGwvLCAncmVnZXhwLmVzY2FwZS5jb250cm9sJ10sXHJcbiAgICAgICAgICAgIFsvXFxcXCQvLCAncmVnZXhwLmVzY2FwZSddLFxyXG4gICAgICAgICAgICBbL0ByZWdleHBlc2MvLCAncmVnZXhwLmVzY2FwZSddLFxyXG4gICAgICAgICAgICBbL1xcXFxcXC4vLCAncmVnZXhwLmludmFsaWQnXSxcclxuICAgICAgICAgICAgWy8jLywgJ3JlZ2V4cC5lc2NhcGUnLCAnQGludGVycG9sYXRlZCddXHJcbiAgICAgICAgXSxcclxuICAgICAgICByZWdleHJhbmdlOiBbXHJcbiAgICAgICAgICAgIFsvLS8sICdyZWdleHAuZXNjYXBlLmNvbnRyb2wnXSxcclxuICAgICAgICAgICAgWy9cXF4vLCAncmVnZXhwLmludmFsaWQnXSxcclxuICAgICAgICAgICAgWy9cXFxcJC8sICdyZWdleHAuZXNjYXBlJ10sXHJcbiAgICAgICAgICAgIFsvQHJlZ2V4cGVzYy8sICdyZWdleHAuZXNjYXBlJ10sXHJcbiAgICAgICAgICAgIFsvW15cXF1dLywgJ3JlZ2V4cCddLFxyXG4gICAgICAgICAgICBbL1xcXS8sICdAYnJhY2tldHMucmVnZXhwLmVzY2FwZS5jb250cm9sJywgJ0Bwb3AnXVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgcmVnZXhwY29tbWVudDogW1xyXG4gICAgICAgICAgICBbL1teKV0rLywgJ2NvbW1lbnQnXSxcclxuICAgICAgICAgICAgWy9cXCkvLCB7IHRva2VuOiAncmVnZXhwLmVzY2FwZS5jb250cm9sJywgbmV4dDogJ0Bwb3AnIH1dXHJcbiAgICAgICAgXSxcclxuICAgICAgICAvLyAlIHF1b3RlZCBzdHJpbmdzXHJcbiAgICAgICAgLy8gQSBiaXQgcmVwZXRpdGl2ZSBzaW5jZSB3ZSBuZWVkIHRvIG9mdGVuIHNwZWNpYWwgY2FzZSB0aGUga2luZCBvZiBlbmRpbmcgZGVsaW1pdGVyXHJcbiAgICAgICAgcHN0cmluZzogW1xyXG4gICAgICAgICAgICBbLyUoW3F3c10pXFwoLywgeyB0b2tlbjogJ3N0cmluZy4kMS5kZWxpbScsIHN3aXRjaFRvOiAnQHFzdHJpbmcuJDEuKC4pJyB9XSxcclxuICAgICAgICAgICAgWy8lKFtxd3NdKVxcWy8sIHsgdG9rZW46ICdzdHJpbmcuJDEuZGVsaW0nLCBzd2l0Y2hUbzogJ0Bxc3RyaW5nLiQxLlsuXScgfV0sXHJcbiAgICAgICAgICAgIFsvJShbcXdzXSlcXHsvLCB7IHRva2VuOiAnc3RyaW5nLiQxLmRlbGltJywgc3dpdGNoVG86ICdAcXN0cmluZy4kMS57Ln0nIH1dLFxyXG4gICAgICAgICAgICBbLyUoW3F3c10pPC8sIHsgdG9rZW46ICdzdHJpbmcuJDEuZGVsaW0nLCBzd2l0Y2hUbzogJ0Bxc3RyaW5nLiQxLjwuPicgfV0sXHJcbiAgICAgICAgICAgIFsvJShbcXdzXSkoQGRlbGltKS8sIHsgdG9rZW46ICdzdHJpbmcuJDEuZGVsaW0nLCBzd2l0Y2hUbzogJ0Bxc3RyaW5nLiQxLiQyLiQyJyB9XSxcclxuICAgICAgICAgICAgWy8lclxcKC8sIHsgdG9rZW46ICdyZWdleHAuZGVsaW0nLCBzd2l0Y2hUbzogJ0BwcmVnZXhwLiguKScgfV0sXHJcbiAgICAgICAgICAgIFsvJXJcXFsvLCB7IHRva2VuOiAncmVnZXhwLmRlbGltJywgc3dpdGNoVG86ICdAcHJlZ2V4cC5bLl0nIH1dLFxyXG4gICAgICAgICAgICBbLyVyXFx7LywgeyB0b2tlbjogJ3JlZ2V4cC5kZWxpbScsIHN3aXRjaFRvOiAnQHByZWdleHAuey59JyB9XSxcclxuICAgICAgICAgICAgWy8lcjwvLCB7IHRva2VuOiAncmVnZXhwLmRlbGltJywgc3dpdGNoVG86ICdAcHJlZ2V4cC48Lj4nIH1dLFxyXG4gICAgICAgICAgICBbLyVyKEBkZWxpbSkvLCB7IHRva2VuOiAncmVnZXhwLmRlbGltJywgc3dpdGNoVG86ICdAcHJlZ2V4cC4kMS4kMScgfV0sXHJcbiAgICAgICAgICAgIFsvJSh4fFd8UT8pXFwoLywgeyB0b2tlbjogJ3N0cmluZy4kMS5kZWxpbScsIHN3aXRjaFRvOiAnQHFxc3RyaW5nLiQxLiguKScgfV0sXHJcbiAgICAgICAgICAgIFsvJSh4fFd8UT8pXFxbLywgeyB0b2tlbjogJ3N0cmluZy4kMS5kZWxpbScsIHN3aXRjaFRvOiAnQHFxc3RyaW5nLiQxLlsuXScgfV0sXHJcbiAgICAgICAgICAgIFsvJSh4fFd8UT8pXFx7LywgeyB0b2tlbjogJ3N0cmluZy4kMS5kZWxpbScsIHN3aXRjaFRvOiAnQHFxc3RyaW5nLiQxLnsufScgfV0sXHJcbiAgICAgICAgICAgIFsvJSh4fFd8UT8pPC8sIHsgdG9rZW46ICdzdHJpbmcuJDEuZGVsaW0nLCBzd2l0Y2hUbzogJ0BxcXN0cmluZy4kMS48Lj4nIH1dLFxyXG4gICAgICAgICAgICBbLyUoeHxXfFE/KShAZGVsaW0pLywgeyB0b2tlbjogJ3N0cmluZy4kMS5kZWxpbScsIHN3aXRjaFRvOiAnQHFxc3RyaW5nLiQxLiQyLiQyJyB9XSxcclxuICAgICAgICAgICAgWy8lKFtycXdzeFddfFE/KS4vLCB7IHRva2VuOiAnaW52YWxpZCcsIG5leHQ6ICdAcG9wJyB9XSxcclxuICAgICAgICAgICAgWy8uLywgeyB0b2tlbjogJ2ludmFsaWQnLCBuZXh0OiAnQHBvcCcgfV0gLy8gcmVjb3ZlclxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgLy8gbm9uLWV4cGFuZGVkIHF1b3RlZCBzdHJpbmcuXHJcbiAgICAgICAgLy8gcXN0cmluZy48a2luZD4uPG9wZW4+LjxjbG9zZT5cclxuICAgICAgICAvLyAga2luZCA9IHF8d3xzICAoc2luZ2xlIHF1b3RlLCBhcnJheSwgc3ltYm9sKVxyXG4gICAgICAgIC8vICBvcGVuID0gb3BlbiBkZWxpbWl0ZXJcclxuICAgICAgICAvLyAgY2xvc2UgPSBjbG9zZSBkZWxpbWl0ZXJcclxuICAgICAgICBxc3RyaW5nOiBbXHJcbiAgICAgICAgICAgIFsvXFxcXCQvLCAnc3RyaW5nLiRTMi5lc2NhcGUnXSxcclxuICAgICAgICAgICAgWy9cXFxcLi8sICdzdHJpbmcuJFMyLmVzY2FwZSddLFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAvLi8sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZXM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJyQjPT0kUzQnOiB7IHRva2VuOiAnc3RyaW5nLiRTMi5kZWxpbScsIG5leHQ6ICdAcG9wJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnJCM9PSRTMyc6IHsgdG9rZW46ICdzdHJpbmcuJFMyLmRlbGltJywgbmV4dDogJ0BwdXNoJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQGRlZmF1bHQnOiAnc3RyaW5nLiRTMidcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICBdLFxyXG4gICAgICAgIC8vIGV4cGFuZGVkIHF1b3RlZCBzdHJpbmcuXHJcbiAgICAgICAgLy8gcXFzdHJpbmcuPGtpbmQ+LjxvcGVuPi48Y2xvc2U+XHJcbiAgICAgICAgLy8gIGtpbmQgPSBRfFd8eCAgKGRvdWJsZSBxdW90ZSwgYXJyYXksIGNvbW1hbmQpXHJcbiAgICAgICAgLy8gIG9wZW4gPSBvcGVuIGRlbGltaXRlclxyXG4gICAgICAgIC8vICBjbG9zZSA9IGNsb3NlIGRlbGltaXRlclxyXG4gICAgICAgIHFxc3RyaW5nOiBbWy8jLywgJ3N0cmluZy4kUzIuZXNjYXBlJywgJ0BpbnRlcnBvbGF0ZWQnXSwgeyBpbmNsdWRlOiAnQHFzdHJpbmcnIH1dLFxyXG4gICAgICAgIC8vIHdoaXRlc3BhY2UgJiBjb21tZW50c1xyXG4gICAgICAgIHdoaXRlc3BhY2U6IFtcclxuICAgICAgICAgICAgWy9bIFxcdFxcclxcbl0rLywgJyddLFxyXG4gICAgICAgICAgICBbL15cXHMqPWJlZ2luXFxiLywgJ2NvbW1lbnQnLCAnQGNvbW1lbnQnXSxcclxuICAgICAgICAgICAgWy8jLiokLywgJ2NvbW1lbnQnXVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgY29tbWVudDogW1xyXG4gICAgICAgICAgICBbL1tePV0rLywgJ2NvbW1lbnQnXSxcclxuICAgICAgICAgICAgWy9eXFxzKj1iZWdpblxcYi8sICdjb21tZW50LmludmFsaWQnXSxcclxuICAgICAgICAgICAgWy9eXFxzKj1lbmRcXGIuKi8sICdjb21tZW50JywgJ0Bwb3AnXSxcclxuICAgICAgICAgICAgWy9bPV0vLCAnY29tbWVudCddXHJcbiAgICAgICAgXVxyXG4gICAgfVxyXG59O1xyXG4iXSwic291cmNlUm9vdCI6IiJ9